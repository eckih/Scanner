<script>
console.log("üîß Direct ActionCable Test startet...");
console.log("üîß window.ActionCable:", typeof window.ActionCable);

document.addEventListener('DOMContentLoaded', function() {
  console.log("üîß DOM loaded - ActionCable Test");
  console.log("üîß window.ActionCable nach DOM load:", typeof window.ActionCable);
  
  // Funktion zum Warten auf ActionCable
  function waitForActionCable(maxAttempts = 20) {
    return new Promise((resolve, reject) => {
      let attempts = 0;
      
      function check() {
        attempts++;
        console.log(`üîß ActionCable Check Versuch ${attempts}:`, typeof window.ActionCable);
        
        if (typeof window.ActionCable !== 'undefined') {
          console.log("üéâ ActionCable gefunden nach", attempts, "Versuchen!");
          resolve();
        } else if (attempts >= maxAttempts) {
          console.log("‚ùå ActionCable nach", attempts, "Versuchen nicht gefunden");
          reject(new Error("ActionCable nicht verf√ºgbar"));
        } else {
          setTimeout(check, 200); // Alle 200ms pr√ºfen
        }
      }
      
      check();
    });
  }
  
  // Warte auf ActionCable und starte dann die Verbindung
  waitForActionCable().then(() => {
    console.log("üîß ActionCable ist verf√ºgbar, starte Verbindung...");
    
    if (typeof window.ActionCable !== 'undefined') {
      console.log("üéâ ActionCable gefunden! Erstelle Verbindung...");
      
      // WebSocket URL bestimmen
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const host = window.location.host;
      const wsUrl = `${protocol}//${host}/cable`;
      
      console.log("üîå WebSocket URL:", wsUrl);
      
      // Consumer erstellen
      const consumer = ActionCable.createConsumer(wsUrl);
      console.log("üîå Consumer erstellt:", consumer);
      
      // PricesChannel subscription
      const subscription = consumer.subscriptions.create("PricesChannel", {
        connected() {
          console.log("üéâ ERFOLGREICH mit PricesChannel verbunden!");
        },
        
        disconnected() {
          console.log("‚ùå Von PricesChannel getrennt");
        },
        
        rejected() {
          console.log("üö´ PricesChannel Subscription abgelehnt");
        },
        
                              received(data) {
               // Debug: Zeige die vollst√§ndige Nachrichtenstruktur
               console.log("üì® Rohe ActionCable-Nachricht:", data);
               console.log("üì® Nachrichtentyp:", typeof data);
               console.log("üì® Nachricht hat message:", 'message' in data);
               
               // ActionCable-Nachrichten sind oft in einem 'message'-Objekt verschachtelt
               const messageData = data.message || data; // Nutze data.message, falls vorhanden, sonst direkt data
               console.log("üì® Verarbeitete Nachrichtendaten:", messageData);
               console.log("üîç Update-Type:", messageData.update_type);
               
               // Behandle Z√§hler-Updates zuerst (diese haben keine cryptocurrency_id)
               if (messageData.update_type === 'counters') {
                 console.log("üìä Z√§hler-Update erhalten:", messageData);
                 handleCounterUpdate(messageData);
                 return;
               }
               
               // Ignoriere Nachrichten ohne cryptocurrency_id oder symbol (au√üer Z√§hler-Updates)
               if (!messageData.cryptocurrency_id || !messageData.symbol) {
                 console.log("[!] Nachricht ohne cryptocurrency_id oder symbol ignoriert:", messageData);
                 return;
               }

               // Behandle verschiedene Update-Typen
               if (messageData.update_type === 'rsi') {
                 console.log("üìä RSI-Update erhalten:", messageData);
                 handleRsiUpdate(messageData);
                 return;
               }
               
               if (messageData.update_type === 'indicator') {
                 console.log("üìä Indikator-Update erhalten:", messageData);
                 handleIndicatorUpdate(messageData);
                 return;
               }
               
               // Behandle Candle-Updates
               if (messageData.type === 'candle_update') {
                 console.log("üïØÔ∏è Candle-Update erhalten:", messageData);
                 console.log("üïØÔ∏è Candle-Update Details:", {
                   symbol: messageData.symbol,
                   cryptoId: messageData.cryptocurrency_id,
                   candlesCount: messageData.candles ? messageData.candles.length : 0,
                   candles: messageData.candles
                 });
                 handleCandleUpdate(messageData);
                 return;
               }
               
               // Unterscheide zwischen Echtzeit-Updates und abgeschlossenen Kerzen (f√ºr Preis-Updates)
               const updateType = messageData.realtime ? "üöÄ ECHTZEIT" : "üìä KERZE";
               console.log(`üì® ${updateType} Preis-Update erhalten:`, messageData);
               
               // DOM Update
               // DEBUG: Zeige verf√ºgbare data-crypto-id Attribute
               const allRows = document.querySelectorAll('[data-crypto-id]');
               console.log("üîç Verf√ºgbare data-crypto-id:", Array.from(allRows).map(r => r.getAttribute('data-crypto-id')));
               console.log("üéØ Suche nach ID:", messageData.cryptocurrency_id);
               
               const row = document.querySelector(`[data-crypto-id='${messageData.cryptocurrency_id}']`);
               if (row) {
                 console.log(`üéØ Zeile gefunden f√ºr Crypto ID: ${messageData.cryptocurrency_id} (${messageData.symbol})`);
                 
                 // Preis-Update
                 const priceCell = row.querySelector('.price-cell');
                 if (priceCell) {
                   const price = parseFloat(messageData.price);
                   const formattedPrice = price >= 1 ? `$${price.toFixed(2)}` : `$${price.toFixed(6)}`;
                   
                   // Erstelle oder aktualisiere den Link
                   let priceLink = priceCell.querySelector('a');
                   if (priceLink) {
                     // Link existiert bereits, nur Text aktualisieren
                     priceLink.textContent = formattedPrice;
                   } else {
                     // Kein Link vorhanden (war N/A), erstelle neuen Link
                     priceCell.innerHTML = `<a href="/cryptocurrencies/${messageData.cryptocurrency_id}/chart" target="_blank" class="text-decoration-none text-primary chart-link" title="Chart anzeigen">${formattedPrice}</a>`;
                   }
                   console.log(`üí∞ ${updateType} Preis aktualisiert: ${formattedPrice} (${messageData.symbol})`);
                   
                   // Verschiedene Animationen f√ºr verschiedene Update-Typen
                   if (messageData.realtime) {
                     // Subtile Animation f√ºr Echtzeit-Updates (h√§ufig)
                     priceCell.style.transition = 'background-color 0.15s ease';
                     priceCell.style.backgroundColor = '#e3f2fd'; // Hellblau f√ºr Echtzeit
                     setTimeout(() => {
                       priceCell.style.backgroundColor = '';
                     }, 150);
                   } else {
                     // Auff√§lligere Animation f√ºr abgeschlossene Kerzen (seltener)
                     priceCell.style.transition = 'background-color 0.5s ease';
                     priceCell.style.backgroundColor = '#d4edda'; // Gr√ºn f√ºr abgeschlossene Kerzen
                     setTimeout(() => {
                       priceCell.style.backgroundColor = '';
                     }, 500);
                   }
                 } else {
                   console.log(`[!] Preis-Zelle nicht gefunden f√ºr ${messageData.symbol}`);
                 }
                 
                 // Preis√§nderungen Update (24h, 1h, 30min) - bei allen Updates
                 if (messageData.price_changes) {
                   console.log("üìä Preis√§nderungen erhalten:", messageData.price_changes);
                   
                   // 24h √Ñnderung Update
                   const change24hCell = row.querySelector('td:nth-child(5)'); // 5. Spalte ist "24h √Ñnderung"
                   if (change24hCell) {
                     const change24h = parseFloat(messageData.price_changes.change_24h);
                     const formattedChange = change24h >= 0 ? `+${change24h.toFixed(2)}%` : `${change24h.toFixed(2)}%`;
                     
                     // Bestimme die Farbe basierend auf Wert und Vollst√§ndigkeit
                     let colorClass = 'text-danger'; // Standard: rot f√ºr unvollst√§ndige Daten
                     
                     if (messageData.price_changes.has_24h_data === true) {
                       // Vollst√§ndige 24h Daten - normale Farben
                       colorClass = change24h >= 0 ? 'text-success' : 'text-danger';
                     } else {
                       // Unvollst√§ndige Daten - immer rot (wie bei 0.00)
                       colorClass = 'text-danger';
                     }
                     
                     // Aktualisiere den Text und die Farbe
                     change24hCell.innerHTML = `
                       <span class="${colorClass}">
                         ${change24h >= 0 ? '<i class="bi bi-arrow-up"></i>' : '<i class="bi bi-arrow-down"></i>'}
                         ${formattedChange}
                       </span>
                     `;
                     
                     const updateType = messageData.price_changes.has_24h_data ? "üìà 24h √Ñnderung (vollst√§ndig)" : "[!] 24h √Ñnderung (unvollst√§ndig)";
                     console.log(`${updateType} aktualisiert: ${formattedChange} (${messageData.symbol})`);
                     
                     // Animation f√ºr 24h √Ñnderung
                     change24hCell.style.transition = 'background-color 0.5s ease';
                     change24hCell.style.backgroundColor = colorClass === 'text-success' ? '#d4edda' : '#f8d7da';
                     setTimeout(() => {
                       change24hCell.style.backgroundColor = '';
                     }, 500);
                   }
                   
                   // 1h √Ñnderung Update
                   const change1hCell = row.querySelector('td:nth-child(6)'); // 6. Spalte ist "1h √Ñnderung"
                   if (change1hCell) {
                     const change1h = parseFloat(messageData.price_changes.change_1h);
                     const formattedChange = change1h >= 0 ? `+${change1h.toFixed(2)}%` : `${change1h.toFixed(2)}%`;
                     
                     // Bestimme die Farbe basierend auf Wert und Vollst√§ndigkeit
                     let colorClass = 'text-danger'; // Standard: rot f√ºr unvollst√§ndige Daten
                     
                     if (messageData.price_changes.has_1h_data === true) {
                       // Vollst√§ndige 1h Daten - normale Farben
                       colorClass = change1h >= 0 ? 'text-success' : 'text-danger';
                     } else {
                       // Unvollst√§ndige Daten - immer rot (wie bei 0.00)
                       colorClass = 'text-danger';
                     }
                     
                     // Aktualisiere den Text und die Farbe
                     change1hCell.innerHTML = `
                       <span class="${colorClass}">
                         ${change1h >= 0 ? '<i class="bi bi-arrow-up"></i>' : '<i class="bi bi-arrow-down"></i>'}
                         ${formattedChange}
                       </span>
                     `;
                     
                     const updateType = messageData.price_changes.has_1h_data ? "üìà 1h √Ñnderung (vollst√§ndig)" : "[!] 1h √Ñnderung (unvollst√§ndig)";
                     console.log(`${updateType} aktualisiert: ${formattedChange} (${messageData.symbol})`);
                     
                     // Animation f√ºr 1h √Ñnderung
                     change1hCell.style.transition = 'background-color 0.5s ease';
                     change1hCell.style.backgroundColor = colorClass === 'text-success' ? '#d4edda' : '#f8d7da';
                     setTimeout(() => {
                       change1hCell.style.backgroundColor = '';
                     }, 500);
                   }
                   
                   // 30min √Ñnderung Update
                   const change30minCell = row.querySelector('td:nth-child(7)'); // 7. Spalte ist "30min √Ñnderung"
                   if (change30minCell) {
                     const change30min = parseFloat(messageData.price_changes.change_30min);
                     const formattedChange = change30min >= 0 ? `+${change30min.toFixed(2)}%` : `${change30min.toFixed(2)}%`;
                     
                     // Bestimme die Farbe basierend auf Wert und Vollst√§ndigkeit
                     let colorClass = 'text-danger'; // Standard: rot f√ºr unvollst√§ndige Daten
                     
                     if (messageData.price_changes.has_30min_data === true) {
                       // Vollst√§ndige 30min Daten - normale Farben
                       colorClass = change30min >= 0 ? 'text-success' : 'text-danger';
                     } else {
                       // Unvollst√§ndige Daten - immer rot (wie bei 0.00)
                       colorClass = 'text-danger';
                     }
                     
                     // Aktualisiere den Text und die Farbe
                     change30minCell.innerHTML = `
                       <span class="${colorClass}">
                         ${change30min >= 0 ? '<i class="bi bi-arrow-up"></i>' : '<i class="bi bi-arrow-down"></i>'}
                         ${formattedChange}
                       </span>
                     `;
                     
                     const updateType = messageData.price_changes.has_30min_data ? "üìà 30min √Ñnderung (vollst√§ndig)" : "[!] 30min √Ñnderung (unvollst√§ndig)";
                     console.log(`${updateType} aktualisiert: ${formattedChange} (${messageData.symbol})`);
                     
                     // Animation f√ºr 30min √Ñnderung
                     change30minCell.style.transition = 'background-color 0.5s ease';
                     change30minCell.style.backgroundColor = colorClass === 'text-success' ? '#d4edda' : '#f8d7da';
                     setTimeout(() => {
                       change30minCell.style.backgroundColor = '';
                     }, 500);
                   }
                 }
                 
                 // Legacy: 24h √Ñnderung Update (nur bei abgeschlossenen Kerzen) - f√ºr Kompatibilit√§t
                 if (messageData.candle_closed && messageData.price_change_24h !== undefined) {
                   const change24hCell = row.querySelector('td:nth-child(5)'); // 5. Spalte ist "24h √Ñnderung"
                   if (change24hCell) {
                     const change24h = parseFloat(messageData.price_change_24h);
                     const formattedChange = messageData.price_change_24h_formatted || 
                       (change24h >= 0 ? `+${change24h.toFixed(2)}%` : `${change24h.toFixed(2)}%`);
                     
                     // Bestimme die Farbe basierend auf Wert und Vollst√§ndigkeit
                     let colorClass = 'text-danger'; // Standard: rot f√ºr unvollst√§ndige Daten
                     
                     if (messageData.price_change_24h_complete === true) {
                       // Vollst√§ndige 24h Daten - normale Farben
                       colorClass = change24h >= 0 ? 'text-success' : 'text-danger';
                     } else {
                       // Unvollst√§ndige Daten - immer rot (wie bei 0.00)
                       colorClass = 'text-danger';
                     }
                     
                     // Aktualisiere den Text und die Farbe
                     change24hCell.innerHTML = `
                       <span class="${colorClass}">
                         ${change24h >= 0 ? '<i class="bi bi-arrow-up"></i>' : '<i class="bi bi-arrow-down"></i>'}
                         ${formattedChange}
                       </span>
                     `;
                     
                     const updateType = messageData.price_change_24h_complete ? "üìà 24h √Ñnderung (vollst√§ndig)" : "[!] 24h √Ñnderung (unvollst√§ndig)";
                     console.log(`${updateType} aktualisiert: ${formattedChange} (${messageData.symbol})`);
                     
                     // Animation f√ºr 24h √Ñnderung
                     change24hCell.style.transition = 'background-color 0.5s ease';
                     change24hCell.style.backgroundColor = colorClass === 'text-success' ? '#d4edda' : '#f8d7da';
                     setTimeout(() => {
                       change24hCell.style.backgroundColor = '';
                     }, 500);
                   }
                 }
                 
                 // Market Cap Update (nur bei abgeschlossenen Kerzen)
                 if (messageData.candle_closed && messageData.market_cap !== undefined) {
                   const marketCapCell = row.querySelector('td:nth-child(6)'); // 6. Spalte ist "Market Cap"
                   if (marketCapCell) {
                     const marketCap = messageData.market_cap_formatted || 'N/A';
                     marketCapCell.textContent = marketCap;
                     
                     console.log(`üìä Market Cap aktualisiert: ${marketCap} (${messageData.symbol})`);
                     
                     // Animation f√ºr Market Cap
                     marketCapCell.style.transition = 'background-color 0.5s ease';
                     marketCapCell.style.backgroundColor = '#e3f2fd'; // Hellblau f√ºr Market Cap
                     setTimeout(() => {
                       marketCapCell.style.backgroundColor = '';
                     }, 500);
                   }
                 }
                 
                 // Volume 24h Update (nur bei abgeschlossenen Kerzen)
                 if (messageData.candle_closed && messageData.volume_24h !== undefined) {
                   const volumeCell = row.querySelector('td:nth-child(7)'); // 7. Spalte ist "Volumen 24h"
                   if (volumeCell) {
                     const volume = messageData.volume_24h_formatted || 'N/A';
                     volumeCell.textContent = volume;
                     
                     console.log(`üìà Volume 24h aktualisiert: ${volume} (${messageData.symbol})`);
                     
                     // Animation f√ºr Volume
                     volumeCell.style.transition = 'background-color 0.5s ease';
                     volumeCell.style.backgroundColor = '#fff3cd'; // Hellgelb f√ºr Volume
                     setTimeout(() => {
                       volumeCell.style.backgroundColor = '';
                     }, 500);
                   }
                 }
               } else {
                 console.log(`‚ùå Keine Zeile gefunden f√ºr Crypto ID: ${messageData.cryptocurrency_id} (${messageData.symbol})`);
                 console.log("üîç Verf√ºgbare Zeilen:", Array.from(document.querySelectorAll('[data-crypto-id]')).map(r => ({
                   id: r.getAttribute('data-crypto-id'),
                   symbol: r.querySelector('td:first-child')?.textContent?.trim()
                 })));
               }
             }
      });
      
      console.log("üì° Subscription erstellt:", subscription);
      
         } else {
       console.error("‚ùå ActionCable nicht verf√ºgbar!");
     }
   }).catch((error) => {
     console.error("‚ùå Fehler beim Laden von ActionCable:", error);
   });

 // Funktion zum Behandeln von RSI-Updates
 function handleRsiUpdate(data) {
   console.log("üìä Verarbeite RSI-Update f√ºr", data.symbol, ":", data.rsi);
   console.log("üîç Suche nach Crypto ID:", data.cryptocurrency_id);
   
   // Debug: Zeige alle verf√ºgbaren data-crypto-id Attribute
   const allRows = document.querySelectorAll('[data-crypto-id]');
   console.log("üîç Verf√ºgbare data-crypto-id:", Array.from(allRows).map(r => ({
     id: r.getAttribute('data-crypto-id'),
     symbol: r.querySelector('td span.badge')?.textContent?.trim()
   })));
   
   const row = document.querySelector(`[data-crypto-id='${data.cryptocurrency_id}']`);
   if (!row) {
     console.log("[!] Zeile nicht gefunden f√ºr Crypto ID:", data.cryptocurrency_id);
     console.log("üîç Versuche Symbol-basierte Suche f√ºr:", data.symbol);
     
     // Fallback: Suche nach Symbol
     const searchSymbol = data.symbol.replace('USDC', '').replace('USDT', '');
     const allTableRows = document.querySelectorAll('tbody tr');
     let foundRow = null;
     
     for (const tableRow of allTableRows) {
       const symbolCell = tableRow.querySelector('td span.badge');
       if (symbolCell && symbolCell.textContent.trim() === searchSymbol) {
         foundRow = tableRow;
         console.log("‚úÖ Zeile gefunden √ºber Symbol-Matching:", data.symbol, "->", searchSymbol);
         break;
       }
     }
     
     if (!foundRow) {
       console.log("‚ùå Keine Zeile gefunden f√ºr Symbol:", data.symbol);
       return;
     }
     
         // Verwende die gefundene Zeile
    const rsiCell = foundRow.querySelector('.rsi-cell');
    if (rsiCell) {
      const rsiValue = parseFloat(data.rsi);
      console.log("üîç RSI-Zelle gefunden, aktualisiere Wert:", rsiValue.toFixed(0));
      rsiCell.textContent = rsiValue.toFixed(0);
      
      // Aktualisiere data-sort Attribut f√ºr korrekte Sortierung
      const rsiTd = rsiCell.closest('td');
      if (rsiTd) {
        rsiTd.setAttribute('data-sort', rsiValue);
        console.log("üìä data-sort Attribut aktualisiert:", rsiValue);
        
        // Zus√§tzliche Sicherheit: Aktualisiere auch das data-sort Attribut der Zelle selbst
        rsiCell.setAttribute('data-sort', rsiValue);
      }
      
      // RSI-Farbe basierend auf Wert
      rsiCell.className = 'badge rsi-cell';
      if (rsiValue >= 70) {
        rsiCell.classList.add('rsi-overbought'); // √úberkauft
      } else if (rsiValue <= 30) {
        rsiCell.classList.add('rsi-oversold'); // √úberverkauft  
      } else {
        rsiCell.classList.add('rsi-neutral'); // Neutral
      }
      
      // Animation f√ºr RSI-Update
      rsiCell.style.transition = 'background-color 0.8s ease';
      rsiCell.style.backgroundColor = '#fff3cd'; // Gelber Hintergrund
      setTimeout(() => {
        rsiCell.style.backgroundColor = '';
      }, 800);
      
      console.log("‚úÖ RSI-Update abgeschlossen f√ºr:", data.symbol, "- Wert:", rsiValue.toFixed(0));
      
      // Sortiere die Tabelle neu nach dem Update
      setTimeout(() => {
        console.log(`üîÑ Starte Neusortierung nach RSI-Update f√ºr ${data.symbol}`);
        forceResortWithRetry();
        
        // Fallback: Manuelle Sortierung nach 500ms
        setTimeout(() => {
          console.log(`üîÑ Fallback: Manuelle Sortierung nach RSI-Update`);
          forceManualSort();
        }, 500);
      }, 100);
    } else {
      console.log("[!] RSI-Zelle nicht gefunden in Symbol-basierter Zeile");
      console.log("üîç Zeilen-HTML:", foundRow.innerHTML);
    }
     return;
   }
   
     const rsiCell = row.querySelector('.rsi-cell');
  if (rsiCell) {
    const rsiValue = parseFloat(data.rsi);
    console.log("üîç RSI-Zelle gefunden, aktualisiere Wert:", rsiValue.toFixed(0));
    rsiCell.textContent = rsiValue.toFixed(0);
    
    // Aktualisiere data-sort Attribut f√ºr korrekte Sortierung
    const rsiTd = rsiCell.closest('td');
    if (rsiTd) {
      rsiTd.setAttribute('data-sort', rsiValue);
      console.log("üìä data-sort Attribut aktualisiert:", rsiValue);
      
      // Zus√§tzliche Sicherheit: Aktualisiere auch das data-sort Attribut der Zelle selbst
      rsiCell.setAttribute('data-sort', rsiValue);
    }
    
    // RSI-Farbe basierend auf Wert
    rsiCell.className = 'badge rsi-cell';
    if (rsiValue >= 70) {
      rsiCell.classList.add('rsi-overbought'); // √úberkauft
    } else if (rsiValue <= 30) {
      rsiCell.classList.add('rsi-oversold'); // √úberverkauft
    } else {
      rsiCell.classList.add('rsi-neutral'); // Neutral
    }
    
    // Animation f√ºr RSI-Update
    rsiCell.style.transition = 'background-color 0.8s ease';
    rsiCell.style.backgroundColor = '#fff3cd'; // Gelber Hintergrund
    setTimeout(() => {
      rsiCell.style.backgroundColor = '';
    }, 800);
    
    console.log("‚úÖ RSI-Update abgeschlossen f√ºr:", data.symbol, "- Wert:", rsiValue.toFixed(0));
    
    // Sortiere die Tabelle neu nach dem Update
    setTimeout(() => {
      console.log(`üîÑ Starte Neusortierung nach RSI-Update f√ºr ${data.symbol}`);
      forceResortWithRetry();
      
      // Fallback: Manuelle Sortierung nach 500ms
      setTimeout(() => {
        console.log(`üîÑ Fallback: Manuelle Sortierung nach RSI-Update`);
        forceManualSort();
      }, 500);
    }, 100);
  } else {
    console.log("[!] RSI-Zelle nicht gefunden f√ºr Crypto ID:", data.cryptocurrency_id);
    console.log("üîç Zeilen-HTML:", row.innerHTML);
  }
 }
 
 // Funktion zum Behandeln von Indikator-Updates
 function handleIndicatorUpdate(data) {
   console.log("üìä Verarbeite Indikator-Update f√ºr", data.symbol, ":", data.indicator_type, "=", data.value);
   
   const row = document.querySelector(`[data-crypto-id='${data.cryptocurrency_id}']`);
   if (!row) {
     console.log("[!] Zeile nicht gefunden f√ºr Crypto ID:", data.cryptocurrency_id);
     return;
   }
   
   // Behandle verschiedene Indikator-Typen
   switch (data.indicator_type) {
          case 'rsi':
       handleRsiUpdate({
         cryptocurrency_id: data.cryptocurrency_id,
         symbol: data.symbol,
         rsi: data.value
       });
            break;
       
          case 'roc':
       handleRocUpdate({
         cryptocurrency_id: data.cryptocurrency_id,
         symbol: data.symbol,
         roc: data.value
       });
            break;
       
     case 'roc_derivative':
       handleRocDerivativeUpdate({
         cryptocurrency_id: data.cryptocurrency_id,
         symbol: data.symbol,
         roc_derivative: data.value
       });
            break;
       
     default:
       console.log(`üìä Unbekannter Indikator-Typ: ${data.indicator_type}`);
   }
 }

 // Funktion zum Behandeln von ROC-Updates
 function handleRocUpdate(data) {
   console.log("üìä Verarbeite ROC-Update f√ºr", data.symbol, ":", data.roc);
   
   const row = document.querySelector(`[data-crypto-id='${data.cryptocurrency_id}']`);
   if (!row) {
     console.log("[!] Zeile nicht gefunden f√ºr ROC Update, Crypto ID:", data.cryptocurrency_id);
     return;
   }
   
     const rocCell = row.querySelector('.roc-cell');
  if (rocCell) {
    const rocValue = parseFloat(data.roc);
    rocCell.textContent = rocValue.toFixed(2);
    
    // Aktualisiere data-sort Attribut f√ºr korrekte Sortierung
    const rocTd = rocCell.closest('td');
    if (rocTd) {
      rocTd.setAttribute('data-sort', rocValue);
      console.log("üìä ROC data-sort Attribut aktualisiert:", rocValue);
      
      // Zus√§tzliche Sicherheit: Aktualisiere auch das data-sort Attribut der Zelle selbst
      rocCell.setAttribute('data-sort', rocValue);
    }
    
    // Aktualisiere CSS-Klassen basierend auf ROC-Wert
    rocCell.className = 'badge roc-cell';
    if (rocValue >= 5) {
      rocCell.classList.add('bg-success');
    } else if (rocValue <= -5) {
      rocCell.classList.add('bg-danger');
        } else {
      rocCell.classList.add('bg-secondary');
        }
    
    console.log(`‚úÖ ROC aktualisiert f√ºr ${data.symbol}: ${rocValue.toFixed(2)}`);
    
    // Sortiere die Tabelle neu nach dem Update
    setTimeout(() => {
      console.log(`üîÑ Starte Neusortierung nach ROC-Update f√ºr ${data.symbol}`);
      forceResortWithRetry();
      
      // Fallback: Manuelle Sortierung nach 500ms
      setTimeout(() => {
        console.log(`üîÑ Fallback: Manuelle Sortierung nach ROC-Update`);
        forceManualSort();
      }, 500);
    }, 100);
      } else {
    console.log("[!] ROC-Zelle nicht gefunden f√ºr", data.symbol);
  }
 }

 // Funktion zum Behandeln von ROC Derivative Updates
 function handleRocDerivativeUpdate(data) {
   console.log("üìä Verarbeite ROC' Update f√ºr", data.symbol, ":", data.roc_derivative);
   
   const row = document.querySelector(`[data-crypto-id='${data.cryptocurrency_id}']`);
   if (!row) {
     console.log("[!] Zeile nicht gefunden f√ºr ROC' Update, Crypto ID:", data.cryptocurrency_id);
    return;
  }
  
     const rocDerivativeCell = row.querySelector('.roc-derivative-cell');
  if (rocDerivativeCell) {
    const rocDerivativeValue = parseFloat(data.roc_derivative);
    rocDerivativeCell.textContent = rocDerivativeValue.toFixed(2);
    
    // Aktualisiere data-sort Attribut f√ºr korrekte Sortierung
    const rocDerivativeTd = rocDerivativeCell.closest('td');
    if (rocDerivativeTd) {
      rocDerivativeTd.setAttribute('data-sort', rocDerivativeValue);
      console.log("üìä ROC' data-sort Attribut aktualisiert:", rocDerivativeValue);
      
      // Zus√§tzliche Sicherheit: Aktualisiere auch das data-sort Attribut der Zelle selbst
      rocDerivativeCell.setAttribute('data-sort', rocDerivativeValue);
    }
    
    // Aktualisiere CSS-Klassen basierend auf ROC' Wert
    rocDerivativeCell.className = 'badge roc-derivative-cell';
    if (rocDerivativeValue >= 2) {
      rocDerivativeCell.classList.add('bg-success');
    } else if (rocDerivativeValue <= -2) {
      rocDerivativeCell.classList.add('bg-danger');
    } else {
      rocDerivativeCell.classList.add('bg-secondary');
    }
    
    console.log(`‚úÖ ROC' aktualisiert f√ºr ${data.symbol}: ${rocDerivativeValue.toFixed(2)}`);
    
    // Sortiere die Tabelle neu nach dem Update
    setTimeout(() => {
      console.log(`üîÑ Starte Neusortierung nach ROC'-Update f√ºr ${data.symbol}`);
      forceResortWithRetry();
      
      // Fallback: Manuelle Sortierung nach 500ms
      setTimeout(() => {
        console.log(`üîÑ Fallback: Manuelle Sortierung nach ROC'-Update`);
        forceManualSort();
      }, 500);
    }, 100);
    } else {
    console.log("[!] ROC'-Zelle nicht gefunden f√ºr", data.symbol);
  }
 }

  // Funktion zum Behandeln von Z√§hler-Updates
  function handleCounterUpdate(data) {
    console.log("üìä Verarbeite Z√§hler-Update:", data);
    
    const messageCounter = document.getElementById('message-counter');
    const klineCounter = document.getElementById('kline-counter');
    const priceUpdateCounter = document.getElementById('price-update-counter');
    const dataRateCounter = document.getElementById('data-rate-counter');

    if (messageCounter) {
      messageCounter.textContent = data.message_counter || 0;
      console.log("üí¨ Nachrichten-Z√§hler aktualisiert:", data.message_counter);
    }
    if (klineCounter) {
      klineCounter.textContent = data.kline_counter || 0;
      console.log("üìà Klines-Z√§hler aktualisiert:", data.kline_counter);
    }
    if (priceUpdateCounter) {
      priceUpdateCounter.textContent = data.price_update_counter || 0;
      console.log("üí∞ Preis-Updates-Z√§hler aktualisiert:", data.price_update_counter);
    }
    if (rsiCalculationCounter) {
      rsiCalculationCounter.textContent = data.rsi_calculation_counter || 0;
      console.log("üìä RSI-Berechnungen-Z√§hler aktualisiert:", data.rsi_calculation_counter);
    }
    if (dataRateCounter) {
      dataRateCounter.textContent = data.data_rate || 0;
      console.log("üíæ Datenrate aktualisiert:", data.data_rate);
    }
}

// Timeframe und RSI-Konfiguration Funktionalit√§t (nur Frontend)
  const timeframeSelector = document.getElementById('timeframe-selector');
  const rsiPeriodInput = document.getElementById('rsi-period-input');
  
  if (timeframeSelector && rsiPeriodInput) {
    // Lade gespeicherte Werte aus localStorage
    const savedTimeframe = localStorage.getItem('selected-timeframe');
    const savedRsiPeriod = localStorage.getItem('selected-rsi-period');
    
                    if (savedTimeframe) {
                  timeframeSelector.value = savedTimeframe;
                  console.log('üïê Gespeicherter Timeframe geladen:', savedTimeframe);
                } else {
                  // Standard: 1 Minute
                  timeframeSelector.value = '1m';
                  localStorage.setItem('selected-timeframe', '1m');
                  console.log('üïê Standard-Timeframe gesetzt: 1m');
                }
                
                if (savedRsiPeriod) {
                  rsiPeriodInput.value = savedRsiPeriod;
                  console.log('üìä Gespeicherte RSI-Periode geladen:', savedRsiPeriod);
                } else {
                  // Standard: 14
                  rsiPeriodInput.value = '14';
                  localStorage.setItem('selected-rsi-period', '14');
                  console.log('üìä Standard-RSI-Periode gesetzt: 14');
                }
                
                // Aktualisiere Backend mit aktuellen Einstellungen beim Laden der Seite
                updateBackendSettings(timeframeSelector.value, rsiPeriodInput.value);
    
                    // Event Listener f√ºr Timeframe-√Ñnderungen
                timeframeSelector.addEventListener('change', function() {
                  const selectedTimeframe = this.value;
                  localStorage.setItem('selected-timeframe', selectedTimeframe);
                  
                  console.log('üïê Timeframe ge√§ndert zu:', selectedTimeframe);
                  
                  // Speichere Timeframe im Rails-Cache f√ºr WebSocket-Service
                  updateBackendSettings(selectedTimeframe, rsiPeriodInput.value);
                  
                  // Zeige Benachrichtigung
                  showTimeframeNotification(selectedTimeframe, 'info');
                  
                  // Starte RSI-Berechnung mit neuem Timeframe
                  startRsiCalculation(selectedTimeframe, rsiPeriodInput.value);
                  
                  // Aktualisiere Mini-Candlesticks mit neuem Timeframe
                  refreshMiniCandlesticks(selectedTimeframe);
                });
    
                    // Event Listener f√ºr RSI-Perioden-√Ñnderungen
                rsiPeriodInput.addEventListener('change', function() {
                  const selectedRsiPeriod = this.value;
                  localStorage.setItem('selected-rsi-period', selectedRsiPeriod);
                  
                  console.log('üìä RSI-Periode ge√§ndert zu:', selectedRsiPeriod);
                  
                  // Speichere RSI-Periode im Rails-Cache f√ºr WebSocket-Service
                  updateBackendSettings(timeframeSelector.value, selectedRsiPeriod);
                  
                  // Zeige Benachrichtigung
                  showRsiPeriodNotification(selectedRsiPeriod, 'info');
                  
                  // Starte RSI-Berechnung mit neuer Periode
                  startRsiCalculation(timeframeSelector.value, selectedRsiPeriod);
                });
    
                    // Funktion zum Aktualisieren der Backend-Einstellungen
                function updateBackendSettings(timeframe, period) {
                  fetch('/cryptocurrencies/update_rsi_settings', {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                      'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''
                    },
                    body: JSON.stringify({ 
                      timeframe: timeframe, 
                      period: parseInt(period) 
                    })
                  })
                  .then(response => response.json())
                  .then(data => {
                    if (data.success) {
                      console.log('‚úÖ Backend-Einstellungen aktualisiert:', data.message);
                    } else {
                      console.error('‚ùå Fehler beim Aktualisieren der Backend-Einstellungen:', data.error);
                    }
                  })
                  .catch(error => {
                    console.error('‚ùå Netzwerkfehler beim Aktualisieren der Backend-Einstellungen:', error);
                  });
                }
                
                // Funktion zum Starten der RSI-Berechnung
                function startRsiCalculation(timeframe, period) {
      console.log('üöÄ Starte RSI-Berechnung:', { timeframe, period });
      
      fetch('/cryptocurrencies/calculate_rsi', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''
        },
        body: JSON.stringify({ 
          timeframe: timeframe, 
          period: parseInt(period) 
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          console.log('‚úÖ RSI-Berechnung gestartet:', data.message);
          showCalculationNotification('RSI-Berechnung gestartet', 'success');
        } else {
          console.error('‚ùå Fehler bei RSI-Berechnung:', data.error);
          showCalculationNotification('Fehler bei RSI-Berechnung', 'error');
        }
      })
      .catch(error => {
        console.error('‚ùå Netzwerkfehler bei RSI-Berechnung:', error);
        showCalculationNotification('Netzwerkfehler bei RSI-Berechnung', 'error');
      });
    }
    
    // Funktion zum Anzeigen einer Berechnungs-Benachrichtigung
    function showCalculationNotification(message, type = 'info') {
      // Entferne bestehende Benachrichtigung
      const existingNotification = document.querySelector('.calculation-notification');
      if (existingNotification) {
        existingNotification.remove();
      }
      
      // Bestimme CSS-Klasse basierend auf Typ
      let alertClass = 'alert-info';
      let icon = 'bi-calculator';
      
      if (type === 'success') {
        alertClass = 'alert-success';
        icon = 'bi-check-circle';
      } else if (type === 'error') {
        alertClass = 'alert-danger';
        icon = 'bi-exclamation-triangle';
      }
      
      // Erstelle neue Benachrichtigung
      const notification = document.createElement('div');
      notification.className = `calculation-notification alert ${alertClass} alert-dismissible fade show position-fixed`;
      notification.style.cssText = 'top: 60px; right: 20px; z-index: 1050; max-width: 300px;';
      
      notification.innerHTML = `
        <i class="bi ${icon}"></i>
        <strong>${message}</strong>
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      document.body.appendChild(notification);
      
      // Automatisch nach 5 Sekunden ausblenden
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 5000);
    }
    
    // Funktion zum Anzeigen einer Benachrichtigung
    function showTimeframeNotification(timeframe, type = 'info') {
      // Entferne bestehende Benachrichtigung
      const existingNotification = document.querySelector('.timeframe-notification');
      if (existingNotification) {
        existingNotification.remove();
      }
      
      // Bestimme CSS-Klasse basierend auf Typ
      let alertClass = 'alert-info';
      let icon = 'bi-clock';
      let message = 'Timeframe ge√§ndert';
      
      if (type === 'success') {
        alertClass = 'alert-success';
        icon = 'bi-check-circle';
        message = 'Timeframe erfolgreich aktualisiert';
      } else if (type === 'error') {
        alertClass = 'alert-danger';
        icon = 'bi-exclamation-triangle';
        message = 'Fehler beim Aktualisieren des Timeframes';
      }
      
      // Erstelle neue Benachrichtigung
      const notification = document.createElement('div');
      notification.className = `timeframe-notification alert ${alertClass} alert-dismissible fade show position-fixed`;
      notification.style.cssText = 'top: 20px; right: 20px; z-index: 1050; max-width: 300px;';
      
      const timeframeLabels = {
        '1m': '1 Minute',
        '5m': '5 Minuten', 
        '15m': '15 Minuten',
        '1h': '1 Stunde',
        '4h': '4 Stunden',
        '1d': '1 Tag'
      };
      
      notification.innerHTML = `
        <i class="bi ${icon}"></i>
        <strong>${message}:</strong> ${timeframeLabels[timeframe]}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      document.body.appendChild(notification);
      
      // Automatisch nach 3 Sekunden ausblenden
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 3000);
    }
    
    // Funktion zum Anzeigen einer RSI-Perioden-Benachrichtigung
    function showRsiPeriodNotification(period, type = 'info') {
      // Entferne bestehende Benachrichtigung
      const existingNotification = document.querySelector('.rsi-period-notification');
      if (existingNotification) {
        existingNotification.remove();
      }
      
      // Bestimme CSS-Klasse basierend auf Typ
      let alertClass = 'alert-info';
      let icon = 'bi-graph-up';
      let message = 'RSI-Periode ge√§ndert';
      
      if (type === 'success') {
        alertClass = 'alert-success';
        icon = 'bi-check-circle';
        message = 'RSI-Periode erfolgreich aktualisiert';
      } else if (type === 'error') {
        alertClass = 'alert-danger';
        icon = 'bi-exclamation-triangle';
        message = 'Fehler beim Aktualisieren der RSI-Periode';
      }
      
      // Erstelle neue Benachrichtigung
      const notification = document.createElement('div');
      notification.className = `rsi-period-notification alert ${alertClass} alert-dismissible fade show position-fixed`;
      notification.style.cssText = 'top: 20px; right: 20px; z-index: 1050; max-width: 300px;';
      
      notification.innerHTML = `
        <i class="bi ${icon}"></i>
        <strong>${message}:</strong> ${period} Kerzen
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      document.body.appendChild(notification);
      
      // Automatisch nach 3 Sekunden ausblenden
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 3000);
    }
    
    // Funktion zum Behandeln von Z√§hler-Updates
    function handleCounterUpdate(data) {
      console.log("üìä Verarbeite Z√§hler-Update:", data);
      
      const messageCounter = document.getElementById('message-counter');
      const klineCounter = document.getElementById('kline-counter');
      const priceUpdateCounter = document.getElementById('price-update-counter');
      const rsiCalculationCounter = document.getElementById('rsi-calculation-counter');
      const dataRateCounter = document.getElementById('data-rate-counter');
      
      console.log("üîç Gefundene Z√§hler-Elemente:", {
        messageCounter: messageCounter,
        klineCounter: klineCounter,
        priceUpdateCounter: priceUpdateCounter,
        dataRateCounter: dataRateCounter
      });
      
      if (messageCounter) {
        messageCounter.textContent = data.message_counter || 0;
        console.log("üí¨ Nachrichten-Z√§hler aktualisiert:", data.message_counter);
      } else {
        console.log("[!] message-counter Element nicht gefunden");
      }
      if (klineCounter) {
        klineCounter.textContent = data.kline_counter || 0;
        console.log("üìà Klines-Z√§hler aktualisiert:", data.kline_counter);
      } else {
        console.log("[!] kline-counter Element nicht gefunden");
      }
      if (priceUpdateCounter) {
        priceUpdateCounter.textContent = data.price_update_counter || 0;
        console.log("üí∞ Preis-Updates-Z√§hler aktualisiert:", data.price_update_counter);
      } else {
        console.log("[!] price-update-counter Element nicht gefunden");
      }
              if (dataRateCounter) {
          dataRateCounter.textContent = data.data_rate || 0;
          console.log("üíæ Datenrate aktualisiert:", data.data_rate);
        } else {
          console.log("[!] data-rate-counter Element nicht gefunden");
        }
    }
    
    // Starte automatische Z√§hler-Updates
    // ENTFERNT: Keine simulierten Z√§hler mehr - wir verwenden echte Daten vom WebSocket-Service...
    console.log("üéØ Warte auf echte Z√§hler-Updates vom WebSocket-Service...");
  }
});
</script>

<div class="container mt-4">
  <div class="row">
    <div class="col-12">
      <div class="d-flex justify-content-between align-items-center mb-4">
        <h1>Kryptow√§hrungen Scanner</h1>
        <!-- Button Einstellungen entfernt -->
      </div>



      <!-- Timeframe und RSI-Konfiguration -->
      <div class="mb-3">
        <div class="d-flex justify-content-between align-items-center">
          <div class="d-flex align-items-center gap-3">
            <div class="d-flex align-items-center">
              <label for="timeframe-selector" class="form-label me-2 mb-0">
                <i class="bi bi-clock"></i> Timeframe:
              </label>
              <select id="timeframe-selector" class="form-select form-select-sm" style="width: auto;">
                <option value="1m">1 Minute</option>
                <option value="5m">5 Minuten</option>
                <option value="15m">15 Minuten</option>
                <option value="1h">1 Stunde</option>
                <option value="4h">4 Stunden</option>
                <option value="1d">1 Tag</option>
              </select>
            </div>
            
            <div class="d-flex align-items-center">
              <label for="rsi-period-input" class="form-label me-2 mb-0">
                <i class="bi bi-graph-up"></i> RSI-Periode:
              </label>
              <input type="number" id="rsi-period-input" class="form-control form-control-sm" 
                     value="14" min="1" max="50" style="width: 80px;"
                     title="Anzahl der Kerzen f√ºr RSI-Berechnung (Standard: 14)">
            </div>
          </div>
          
          <!-- Live-Daten Status -->
          <div>
            <small class="text-success">
              <i class="bi bi-check-circle"></i> Live-Daten von Binance API (1m Updates)
            </small>
          </div>
        </div>
      </div>

      <!-- Durchschnittswerte -->
        <% if @average_rsi || @average_roc || @average_roc_derivative %>
          <div class="mb-2">
            <div class="d-flex gap-3 justify-content-end">
              <% if @average_rsi %>
                <% rsi_trend_icon = case @rsi_trend
                                     when 'up' then 'bi-arrow-up-right text-success'
                                     when 'down' then 'bi-arrow-down-right text-danger'
                                     else 'bi-arrow-right text-muted'
                                   end %>
                <small class="text-info averages-tooltip" 
                       data-bs-toggle="tooltip" 
                       data-bs-html="true"
                       data-bs-placement="bottom"
                       data-bs-custom-class="chart-tooltip"
                       data-chart-type="rsi"
                       title="<div class='text-center'>
                         <strong>RSI Durchschnitt</strong><br>
                         <span class='h5 text-info'><%= @average_rsi %></span><br>
                         <small class='text-muted'>Relative Strength Index</small><br>
                         <div class='mt-2'>
                           <i class='bi <%= rsi_trend_icon %>'></i>
                           <small class='text-muted ms-1'>Trend: <%= @rsi_trend == 'up' ? 'Anstieg' : (@rsi_trend == 'down' ? 'R√ºckgang' : 'Gleichbleibend') %></small>
                         </div>
                         <div class='mt-2'>
                           <canvas id='rsi-chart' width='200' height='60' style='max-width: 200px; max-height: 60px; border: 1px solid rgba(255,255,255,0.2);'></canvas>
                         </div>
                       </div>">
                  <%= link_to averages_chart_cryptocurrencies_path, target: '_blank', class: 'text-decoration-none text-info' do %>
                    <i class="bi bi-speedometer2"></i> RSI √ò: <strong><%= @average_rsi %></strong>
                    <i class="bi <%= rsi_trend_icon %> ms-1"></i>
                  <% end %>
                </small>
              <% end %>
            </div>
          </div>
        <% end %>
    </div>
  </div>
</div>

<% if @cryptocurrencies.any? %>
  <!-- Responsive Table View (alle Bildschirmgr√∂√üen) -->
  <div class="table-responsive">
    <table id="crypto-table" class="table table-hover">
      <thead class="table-dark">
        <tr>
          <th class="d-none d-md-table-cell">Rang</th>
          <th class="d-none d-lg-table-cell">Name</th>
          <th>Symbol</th>
          <th>Preis</th>
          <th class="d-none d-lg-table-cell">24h √Ñnderung</th>
          <th class="d-none d-xl-table-cell">1h √Ñnderung</th>
          <th class="d-none d-xl-table-cell">30min √Ñnderung</th>
          <th class="d-none d-xl-table-cell">Market Cap</th>
          <th class="d-none d-xl-table-cell">Volumen 24h (USD)</th>
          <th>
            RSI
            <% if @average_rsi %>
              <br><small class="text-info d-none d-md-inline">√ò <%= @average_rsi %></small>
            <% end %>
          </th>
          <th class="d-none d-lg-table-cell">
            ROC in %
          </th>
          <th class="d-none d-lg-table-cell">
            ROC' in %
          </th>
          <th>Chart</th>
          <th class="d-none d-lg-table-cell">
            1h Kerze
          </th>
        </tr>
      </thead>
      <tbody>
        <% @cryptocurrencies.each_with_index do |crypto, crypto_index| %>
          <tr data-crypto-id="<%= crypto.id %>">
            <td class="d-none d-md-table-cell">
              <span class="badge bg-secondary">#<%= crypto.market_cap_rank %></span>
            </td>
            <td class="d-none d-lg-table-cell">
              <strong><%= crypto.display_name %></strong>
            </td>
            <td>
              <%= link_to "https://www.binance.com/en/trade/#{crypto.base_symbol}_USDC?_from=markets&type=spot", 
                  target: '_blank',
                  class: 'text-decoration-none',
                  title: "#{crypto.display_name} auf Binance handeln" do %>
                <span class="badge bg-light text-dark"><%= crypto.base_symbol %></span>
              <% end %>
              <span class="d-md-none">
                <br><small class="text-muted">#<%= crypto.market_cap_rank %></small>
              </span>
            </td>
            <td data-sort="<%= @latest_prices[crypto.id] || 0 %>">
              <strong class="price-cell">
                <% price = @latest_prices[crypto.id] %>
                <% if price.present? %>
                  <%= link_to (price >= 1 ? "$#{price.round(2)}" : "$#{price.round(6)}"), chart_cryptocurrency_path(crypto), target: '_blank', class: 'text-decoration-none text-primary chart-link', title: 'Chart anzeigen' %>
                <% else %>
                  <span class="text-muted">N/A</span>
                <% end %>
              </strong>
            </td>
            <td class="d-none d-lg-table-cell">
              <% if crypto.price_change_percentage_24h %>
                <%# Bestimme die Farbe basierend auf Vollst√§ndigkeit der 24h-Daten %>
                <% color_class = if crypto.price_change_24h_complete?
                                   crypto.price_change_percentage_24h >= 0 ? 'text-success' : 'text-danger'
                                 else
                                   'text-danger' # Unvollst√§ndige Daten immer rot
                                 end %>
                <span class="<%= color_class %>">
                  <% if crypto.price_change_percentage_24h >= 0 %>
                    <i class="bi bi-arrow-up"></i>
                  <% else %>
                    <i class="bi bi-arrow-down"></i>
                  <% end %>
                  <%= crypto.price_change_percentage_24h_formatted %>
                </span>
              <% else %>
                <span class="text-muted">0.00%</span>
              <% end %>
            </td>
            <td class="d-none d-xl-table-cell">
              <% if crypto.price_change_percentage_1h %>
                <%# Bestimme die Farbe basierend auf Vollst√§ndigkeit der 1h-Daten %>
                <% color_class = if crypto.price_change_1h_complete?
                                   crypto.price_change_percentage_1h >= 0 ? 'text-success' : 'text-danger'
                                 else
                                   'text-danger' # Unvollst√§ndige Daten immer rot
                                 end %>
                <span class="<%= color_class %>">
                  <% if crypto.price_change_percentage_1h >= 0 %>
                    <i class="bi bi-arrow-up"></i>
                  <% else %>
                    <i class="bi bi-arrow-down"></i>
                  <% end %>
                  <%= crypto.price_change_percentage_1h_formatted %>
                </span>
              <% else %>
                <span class="text-muted">0.00%</span>
              <% end %>
            </td>
            <td class="d-none d-xl-table-cell">
              <% if crypto.price_change_percentage_30min %>
                <%# Bestimme die Farbe basierend auf Vollst√§ndigkeit der 30min-Daten %>
                <% color_class = if crypto.price_change_30min_complete?
                                   crypto.price_change_percentage_30min >= 0 ? 'text-success' : 'text-danger'
                                 else
                                   'text-danger' # Unvollst√§ndige Daten immer rot
                                 end %>
                <span class="<%= color_class %>">
                  <% if crypto.price_change_percentage_30min >= 0 %>
                    <i class="bi bi-arrow-up"></i>
                  <% else %>
                    <i class="bi bi-arrow-down"></i>
                  <% end %>
                  <%= crypto.price_change_percentage_30min_formatted %>
                </span>
              <% else %>
                <span class="text-muted">0.00%</span>
              <% end %>
            </td>
            <td class="d-none d-xl-table-cell"><%= crypto.formatted_market_cap %></td>
            <td class="d-none d-xl-table-cell">
              <%= crypto.formatted_volume_24h %>
            </td>
            <td data-sort="<%= crypto.current_rsi(@current_timeframe) || -1 %>">
              <% if crypto.current_rsi(@current_timeframe) %>
                <% rsi_class = if crypto.current_rsi(@current_timeframe) <= 30
                                 "rsi-oversold"
                               elsif crypto.current_rsi(@current_timeframe) >= 70
                                 "rsi-overbought"
                               else
                                 "rsi-neutral"
                               end %>
                <%= link_to chart_cryptocurrency_path(crypto), 
                    target: '_blank',
                    class: 'text-decoration-none',
                    title: "RSI Chart anzeigen" do %>
                  <span class="badge <%= rsi_class %> chart-link rsi-cell">
                    <%= crypto.current_rsi(@current_timeframe).to_i %>
                  </span>
                <% end %>
              <% else %>
                <span class="badge bg-secondary rsi-cell">N/A</span>
              <% end %>
            </td>
            
            <td class="d-none d-lg-table-cell" data-sort="<%= crypto.current_roc(@current_timeframe) || -999 %>">
              <% if crypto.current_roc(@current_timeframe) %>
                <% roc_class = if crypto.current_roc(@current_timeframe) >= 5
                                 "bg-success"
                               elsif crypto.current_roc(@current_timeframe) <= -5
                                 "bg-danger"
                               else
                                 "bg-secondary"
                               end %>
                <span class="badge <%= roc_class %> roc-cell">
                  <%= crypto.current_roc(@current_timeframe).round(2) %>
                </span>
              <% else %>
                <span class="badge bg-secondary roc-cell">N/A</span>
              <% end %>
            </td>
            
            <td class="d-none d-lg-table-cell" data-sort="<%= crypto.current_roc_derivative(@current_timeframe) || -999 %>">
              <% if crypto.current_roc_derivative(@current_timeframe) %>
                <% roc_derivative_class = if crypto.current_roc_derivative(@current_timeframe) >= 2
                                            "bg-success"
                                          elsif crypto.current_roc_derivative(@current_timeframe) <= -2
                                            "bg-danger"
                                          else
                                            "bg-secondary"
                                          end %>
                <span class="badge <%= roc_derivative_class %> roc-derivative-cell">
                  <%= crypto.current_roc_derivative(@current_timeframe).round(2) %>
                </span>
              <% else %>
                <span class="badge bg-secondary roc-derivative-cell">N/A</span>
              <% end %>
            </td>
                         <td>
               <div class="mini-candlestick-container" data-crypto-id="<%= crypto.id %>" data-symbol="<%= crypto.symbol %>">
                 <canvas class="mini-candlestick" width="80" height="30" data-crypto-id="<%= crypto.id %>"></canvas>
                 <!-- Individuelle Tooltips f√ºr jede Kerze werden dynamisch erstellt -->
               </div>
             </td>
             <td class="d-none d-lg-table-cell">
               <div class="current-1h-candles-container" data-crypto-id="<%= crypto.id %>" data-symbol="<%= crypto.symbol %>">
                 <canvas class="current-1h-candles" width="180" height="40" data-crypto-id="<%= crypto.id %>"></canvas>
                 <div class="candlestick-info d-none">
                   <small class="text-muted">O: <span class="open-price">-</span></small><br>
                   <small class="text-muted">H: <span class="high-price">-</span></small><br>
                   <small class="text-muted">L: <span class="low-price">-</span></small><br>
                   <small class="text-muted">C: <span class="close-price">-</span></small>
                 </div>
               </div>
             </td>
          </tr>
        <% end %>
      </tbody>
    </table>
  </div>

  <!-- WebSocket Z√§hler unterhalb der Tabelle -->
  <div class="mt-4">
    <div class="row">
      <div class="col-md-3">
        <div class="card border-primary">
          <div class="card-body text-center py-2">
            <h6 class="card-title text-primary mb-1">
              <i class="bi bi-envelope"></i> Nachrichten
            </h6>
            <div class="h4 mb-0 text-primary" id="message-counter">0</div>
            <small class="text-muted">Empfangen</small>
          </div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card border-success">
          <div class="card-body text-center py-2">
            <h6 class="card-title text-success mb-1">
              <i class="bi bi-graph-up"></i> Klines
            </h6>
            <div class="h4 mb-0 text-success" id="kline-counter">0</div>
            <small class="text-muted">Verarbeitet</small>
          </div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card border-warning">
          <div class="card-body text-center py-2">
            <h6 class="card-title text-warning mb-1">
              <i class="bi bi-currency-dollar"></i> Preis-Updates
            </h6>
            <div class="h4 mb-0 text-warning" id="price-update-counter">0</div>
            <small class="text-muted">Gesendet</small>
          </div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card border-info">
          <div class="card-body text-center py-2">
            <h6 class="card-title text-info mb-1">
              <i class="bi bi-speedometer"></i> Datenrate
            </h6>
            <div class="h4 mb-0 text-info" id="data-rate-counter">0</div>
            <small class="text-muted">Nachrichten/min</small>
          </div>
        </div>
      </div>
    </div>
  </div>

<% else %>
  <!-- Empty State -->
  <div class="text-center py-5">
    <i class="bi bi-exclamation-triangle display-1 text-warning"></i>
    <h3 class="mt-3">Keine Daten verf√ºgbar</h3>
    <p class="text-muted">
      Es konnten keine Kryptow√§hrungsdaten geladen werden. 
      Bitte √ºberpr√ºfen Sie Ihre Internetverbindung und versuchen Sie es erneut.
    </p>
  </div>
<% end %> 

<style>
/* Mini-Candlestick Styling */
.mini-candlestick-container {
  position: relative;
  display: inline-block;
}

.mini-candlestick {
  border: 1px solid #dee2e6;
  border-radius: 4px;
  background-color: #f8f9fa;
  cursor: pointer;
  transition: all 0.2s ease;
}

.mini-candlestick:hover {
  border-color: #007bff;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

/* Aktuelle 1h Kerzen Styling */
.current-1h-candles-container {
  position: relative;
  display: inline-block;
}

.current-1h-candles {
  border: 1px solid #dee2e6;
  border-radius: 4px;
  background-color: #f8f9fa;
  cursor: pointer;
  transition: all 0.2s ease;
}

.current-1h-candles:hover {
  border-color: #28a745;
  box-shadow: 0 0 0 0.2rem rgba(40, 167, 69, 0.25);
}

.current-1h-candles.incomplete {
  border-color: #ffc107;
  background-color: #fff3cd;
}

.current-1h-candles.complete {
  border-color: #28a745;
  background-color: #d4edda;
}

.current-1h-candles.old {
  border-color: #6c757d;
  background-color: #f8f9fa;
  opacity: 0.7;
}

.candlestick-info {
  position: absolute;
  top: -80px;
  left: 50%;
  transform: translateX(-50%);
  background-color: #343a40;
  color: white;
  padding: 8px;
  border-radius: 4px;
  font-size: 11px;
  z-index: 1000;
  white-space: nowrap;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.candlestick-info::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 4px solid transparent;
  border-top-color: #343a40;
}

/* Individuelle Tooltips f√ºr jede Kerze */
.candlestick-tooltip {
  position: absolute;
  background-color: #343a40;
  color: white;
  padding: 8px;
  border-radius: 4px;
  font-size: 11px;
  z-index: 1000;
  white-space: nowrap;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  pointer-events: none;
  transition: opacity 0.2s ease;
}

.candlestick-tooltip::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 4px solid transparent;
  border-top-color: #343a40;
}

/* Positionierung f√ºr verschiedene Kerzen */
.candlestick-tooltip-0 { top: -80px; left: 10%; }
.candlestick-tooltip-1 { top: -80px; left: 30%; }
.candlestick-tooltip-2 { top: -80px; left: 50%; }
.candlestick-tooltip-3 { top: -80px; left: 70%; }
.candlestick-tooltip-4 { top: -80px; left: 90%; }

/* Responsive Anpassungen */
@media (max-width: 768px) {
  .mini-candlestick {
    width: 60px !important;
    height: 25px !important;
  }
  
  .current-1h-candles {
    width: 150px !important;
    height: 30px !important;
  }
  
  .candlestick-info {
    font-size: 10px;
    padding: 6px;
  }
}
</style>

<script>
            // Mini-Candlestick Charts f√ºr die Tabelle
            document.addEventListener('DOMContentLoaded', function() {
              console.log('üïØÔ∏è DOMContentLoaded - Initialisiere Charts...');
              
              // Debug: Zeige alle 1h Kerzen-Canvases sofort
              const current1hCanvases = document.querySelectorAll('.current-1h-candles');
              console.log(`üîç Sofort gefundene 1h Kerzen-Canvases: ${current1hCanvases.length}`);
              current1hCanvases.forEach((canvas, index) => {
                console.log(`üîç Canvas ${index}:`, canvas);
                console.log(`üîç Crypto ID:`, canvas.dataset.cryptoId);
              });
              const candlestickCanvases = document.querySelectorAll('.mini-candlestick');

              candlestickCanvases.forEach(canvas => {
                const cryptoId = canvas.dataset.cryptoId;
                const container = canvas.closest('.mini-candlestick-container');
                const infoDiv = container.querySelector('.candlestick-info');

                // Lade echte Candlestick-Daten vom Server
                const candlestickData = loadRealCandlestickData(cryptoId);

                // Zeichne Mini-Candlesticks
                drawMiniCandlesticks(canvas, candlestickData);

                // Erstelle individuelle Tooltips f√ºr jede Kerze
                console.log(`üïØÔ∏è Erstelle Tooltips f√ºr ${candlestickData.length} Kerzen`);
                createIndividualTooltips(container, candlestickData.length);
                
                // Debug: Zeige alle erstellten Tooltips
                const createdTooltips = container.querySelectorAll('.candlestick-tooltip');
                console.log(`üîç Erstellte Tooltips: ${createdTooltips.length}`);
                createdTooltips.forEach((tooltip, index) => {
                  console.log(`üîç Tooltip ${index}:`, tooltip.className);
                });
                
                // Tooltip-Funktionalit√§t f√ºr Mini-Candlesticks (individuelle Kerzen)
                canvas.addEventListener('mousemove', function(e) {
                  const rect = canvas.getBoundingClientRect();
                  const x = e.clientX - rect.left;
                  const candleWidth = canvas.width / candlestickData.length;
                  const candleIndex = Math.floor(x / candleWidth);
                  
                  // Begrenze den Index auf g√ºltige Werte
                  const validIndex = Math.max(0, Math.min(candleIndex, candlestickData.length - 1));
                  
                  console.log(`üïØÔ∏è Mouse-Position: x=${x}, candleWidth=${candleWidth}, candleIndex=${candleIndex}, validIndex=${validIndex}`);
                  
                  // Zeige nur den Tooltip f√ºr die aktuelle Kerze
                  hideAllTooltips(container);
                  if (candlestickData[validIndex]) {
                    showTooltip(container, validIndex, candlestickData[validIndex]);
                  }
                });

                canvas.addEventListener('mouseleave', function() {
                  hideAllTooltips(container);
                });
                
                // Aktualisiere Tooltips bei Mouse-Enter
                canvas.addEventListener('mouseenter', function() {
                  console.log(`üïØÔ∏è Mouse-Enter f√ºr ${cryptoId} - ${candlestickData.length} Kerzen verf√ºgbar`);
                  
                  // Test: Zeige alle verf√ºgbaren Tooltips
                  const allTooltips = container.querySelectorAll('.candlestick-tooltip');
                  console.log(`üîç Verf√ºgbare Tooltips bei Mouse-Enter: ${allTooltips.length}`);
                  allTooltips.forEach((tooltip, index) => {
                    console.log(`üîç Tooltip ${index}:`, tooltip.className, tooltip.classList.contains('d-none') ? '(versteckt)' : '(sichtbar)');
                  });
                });
              });
              
              // Aktuelle 1h Kerzen f√ºr die Tabelle
              const current1hCandlesCanvases = document.querySelectorAll('.current-1h-candles');
              console.log(`üïØÔ∏è Gefundene 1h Kerzen-Canvases: ${current1hCandlesCanvases.length}`);

              current1hCandlesCanvases.forEach(canvas => {
                const cryptoId = canvas.dataset.cryptoId;
                const container = canvas.closest('.current-1h-candles-container');
                const infoDiv = container.querySelector('.candlestick-info');

                console.log(`üïØÔ∏è Initialisiere 1h Kerzen f√ºr Crypto ID: ${cryptoId}`);

                // Lade aktuelle 1h Kerzen-Daten vom Server
                let current1hData = loadCurrent1hCandlesData(cryptoId);
                console.log(`üïØÔ∏è Geladene 1h Daten f√ºr ${cryptoId}:`, current1hData);

                // Zeichne aktuelle 1h Kerzen
                if (current1hData && current1hData.length > 0) {
                  drawCurrent1hCandles(canvas, current1hData);
                  console.log(`‚úÖ 1h Kerzen aus Server-Daten gezeichnet f√ºr ${cryptoId}`);
                } else {
                  console.log(`‚ö†Ô∏è Keine 1h Daten vom Server f√ºr ${cryptoId} - zeichne leeren Chart`);
                  drawCurrent1hCandles(canvas, null);
                }

                // Tooltip-Funktionalit√§t f√ºr 1h Kerzen
                canvas.addEventListener('mouseenter', function() {
                  infoDiv.classList.remove('d-none');
                  if (current1hData && current1hData.length > 0) {
                    update1hCandlesInfo(infoDiv, current1hData);
                  }
                });

                canvas.addEventListener('mouseleave', function() {
                  infoDiv.classList.add('d-none');
                });
              });
            });

            // Lade echte Candlestick-Daten vom Server
            let candlestickDataCache = <%= raw @mini_candlestick_data.to_json %>;
            console.log('üïØÔ∏è Initialer Candlestick-Daten-Cache:', candlestickDataCache);
            console.log('üïØÔ∏è Cache-Keys:', Object.keys(candlestickDataCache));
            console.log('üïØÔ∏è Cache-Gr√∂√üe:', Object.keys(candlestickDataCache).length);
            
            // Lade aktuelle 1h Kerzen-Daten vom Server
            let current1hCandlesCache = <%= raw @current_1h_candle_data.to_json %>;
            console.log('üïØÔ∏è Initialer 1h Kerzen-Cache:', current1hCandlesCache);
            console.log('üïØÔ∏è 1h Cache-Keys:', Object.keys(current1hCandlesCache));
            console.log('üïØÔ∏è 1h Cache-Gr√∂√üe:', Object.keys(current1hCandlesCache).length);
            
            function loadRealCandlestickData(cryptoId) {
              // Verwende die gecachten Daten
              const data = candlestickDataCache[cryptoId] || [];
              console.log(`üïØÔ∏è Lade Daten f√ºr Crypto ID ${cryptoId}:`, data);
              return data;
            }
            
            // Update die gecachten Daten (immer nur die letzten 5 Kerzen behalten)
            function updateCandlestickDataCache(cryptoId, newData) {
              if (Array.isArray(newData)) {
                candlestickDataCache[cryptoId] = newData.slice(-5);
              } else {
                candlestickDataCache[cryptoId] = [];
              }
            }
            
            // Lade aktuelle 1h Kerzen-Daten
            function loadCurrent1hCandlesData(cryptoId) {
              const data = current1hCandlesCache[cryptoId] || null;
              console.log(`üïØÔ∏è Lade 1h Kerzen-Daten f√ºr Crypto ID ${cryptoId}:`, data);
              
              // Debug: Zeige alle verf√ºgbaren Cache-Daten
              if (!data) {
                console.log(`‚ö†Ô∏è Keine 1h Daten f√ºr ${cryptoId} im Cache`);
                console.log(`üîç Verf√ºgbare Cache-Keys:`, Object.keys(current1hCandlesCache));
                console.log(`üîç Cache-Inhalt:`, current1hCandlesCache);
                
                // Tempor√§re L√∂sung: Versuche 1h Daten aus Mini-Candlestick-Daten zu generieren
                const miniData = candlestickDataCache[cryptoId] || [];
                if (miniData.length > 0) {
                  console.log(`üïØÔ∏è Verwende Mini-Candlestick-Daten als Fallback f√ºr 1h Kerzen`);
                  const lastCandle = miniData[miniData.length - 1];
                  return [{
                    open: lastCandle.open,
                    high: lastCandle.high,
                    low: lastCandle.low,
                    close: lastCandle.close,
                    timestamp: lastCandle.timestamp,
                    isGreen: lastCandle.isGreen,
                    isComplete: false,
                    isCurrentHour: false
                  }];
                }
              }
              
              return data;
            }
            
            // Update die gecachten 1h Kerzen-Daten
            function updateCurrent1hCandlesCache(cryptoId, newData) {
              current1hCandlesCache[cryptoId] = newData;
            }
            
            // Generiere 1h Kerzen-Daten aus Mini-Candlestick-Daten
            function generateCurrent1hCandlesData(cryptoId) {
              console.log(`üïØÔ∏è Generiere 1h Kerzen-Daten f√ºr Crypto ID: ${cryptoId}`);
              
              const miniData = candlestickDataCache[cryptoId] || [];
              if (miniData.length === 0) {
                console.log(`‚ö†Ô∏è Keine Mini-Candlestick-Daten f√ºr ${cryptoId} verf√ºgbar`);
                return null;
              }
              
              // Verwende die letzten 3 Kerzen als 1h Kerzen
              const last3Candles = miniData.slice(-3);
              const currentTime = new Date();
              
              const generatedData = last3Candles.map((candle, index) => {
                const candleTime = new Date(candle.timestamp);
                const isCurrentHour = currentTime.getHours() === candleTime.getHours() && 
                                     currentTime.getDate() === candleTime.getDate();
                
                return {
                  open: parseFloat(candle.open),
                  high: parseFloat(candle.high),
                  low: parseFloat(candle.low),
                  close: parseFloat(candle.close),
                  timestamp: candle.timestamp,
                  isGreen: parseFloat(candle.close) > parseFloat(candle.open),
                  isComplete: !isCurrentHour,
                  isCurrentHour: isCurrentHour
                };
              });
              
              console.log(`‚úÖ 1h Kerzen-Daten generiert f√ºr ${cryptoId}:`, generatedData);
              return generatedData;
            }
            
            // Finde die letzte vollst√§ndige Kerze aus Mini-Candlestick-Daten
            function findLastCompleteCandle(cryptoId) {
              console.log(`üïØÔ∏è Suche letzte vollst√§ndige Kerze f√ºr Crypto ID: ${cryptoId}`);
              
              const miniData = candlestickDataCache[cryptoId] || [];
              if (miniData.length === 0) {
                console.log(`‚ö†Ô∏è Keine Mini-Candlestick-Daten f√ºr ${cryptoId} verf√ºgbar`);
                return null;
              }
              
              const currentTime = new Date();
              
              // Suche die letzte vollst√§ndige Kerze (nicht aus der aktuellen Stunde)
              for (let i = miniData.length - 1; i >= 0; i--) {
                const candle = miniData[i];
                const candleTime = new Date(candle.timestamp);
                
                // Pr√ºfe ob Kerze nicht aus der aktuellen Stunde ist
                if (currentTime.getHours() !== candleTime.getHours() || 
                    currentTime.getDate() !== candleTime.getDate()) {
                  console.log(`‚úÖ Letzte vollst√§ndige Kerze gefunden f√ºr ${cryptoId}:`, candle);
                  return candle;
                }
              }
              
              // Falls keine vollst√§ndige Kerze gefunden, verwende die letzte
              const lastCandle = miniData[miniData.length - 1];
              console.log(`‚ö†Ô∏è Keine vollst√§ndige Kerze gefunden, verwende letzte Kerze f√ºr ${cryptoId}:`, lastCandle);
              return lastCandle;
            }
            


// Zeichne Mini-Candlesticks
function drawMiniCandlesticks(canvas, data) {
  console.log(`üïØÔ∏è drawMiniCandlesticks aufgerufen f√ºr Canvas:`, canvas);
  console.log(`üïØÔ∏è Daten:`, data);
  console.log(`üïØÔ∏è Daten-Typ:`, typeof data);
  console.log(`üïØÔ∏è Daten-L√§nge:`, data ? data.length : 'undefined');
  
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  
  console.log(`üïØÔ∏è Canvas-Dimensionen: ${width}x${height}`);
  
  // Clear canvas
  ctx.clearRect(0, 0, width, height);
  
  if (!data || data.length === 0) {
    console.log('‚ö†Ô∏è Keine Candlestick-Daten verf√ºgbar - Mini-Chart bleibt leer');
    
    // Zeichne einen Platzhalter-Text
    ctx.fillStyle = '#6c757d';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Keine Daten', width / 2, height / 2);
    return;
  }
  
  // Debug: Zeige die ersten und letzten Kerzen
  if (data.length > 0) {
    console.log(`üïØÔ∏è Erste Kerze:`, data[0]);
    console.log(`üïØÔ∏è Letzte Kerze:`, data[data.length - 1]);
  }
  
  const candleWidth = width / data.length;
  const padding = 2;
  const availableHeight = height - 4;
  
  // Konvertiere alle Preise zu Numbers und finde min/max f√ºr Skalierung
  const processedData = data.map(d => ({
    open: parseFloat(d.open),
    high: parseFloat(d.high),
    low: parseFloat(d.low),
    close: parseFloat(d.close),
    isGreen: d.isGreen || parseFloat(d.close) > parseFloat(d.open)
  }));
  
  const allPrices = processedData.flatMap(d => [d.low, d.high]);
  const minPrice = Math.min(...allPrices);
  const maxPrice = Math.max(...allPrices);
  const priceRange = maxPrice - minPrice;
  
  processedData.forEach((candle, index) => {
    const x = index * candleWidth + padding;
    const candleX = x + candleWidth * 0.1;
    const candleW = candleWidth * 0.8;
    
    // Skaliere Preise auf Canvas-H√∂he
    const highY = ((maxPrice - candle.high) / priceRange) * availableHeight + 2;
    const lowY = ((maxPrice - candle.low) / priceRange) * availableHeight + 2;
    const openY = ((maxPrice - candle.open) / priceRange) * availableHeight + 2;
    const closeY = ((maxPrice - candle.close) / priceRange) * availableHeight + 2;
    
    // Zeichne Docht (High-Low Linie)
    ctx.strokeStyle = candle.isGreen ? '#28a745' : '#dc3545';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x + candleWidth / 2, highY);
    ctx.lineTo(x + candleWidth / 2, lowY);
    ctx.stroke();
    
    // Zeichne Kerze (Open-Close Rechteck)
    const candleTop = Math.min(openY, closeY);
    const candleBottom = Math.max(openY, closeY);
    const candleHeight = Math.abs(closeY - openY);
    
    if (candleHeight === 0) {
      // Doji - nur horizontale Linie
      ctx.strokeStyle = candle.isGreen ? '#28a745' : '#dc3545';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(candleX, openY);
      ctx.lineTo(candleX + candleW, openY);
      ctx.stroke();
    } else {
      // Normale Kerze
      ctx.fillStyle = candle.isGreen ? '#28a745' : '#dc3545';
      ctx.fillRect(candleX, candleTop, candleW, candleHeight);
      
      // Kerzen-Rand
      ctx.strokeStyle = candle.isGreen ? '#28a745' : '#dc3545';
      ctx.lineWidth = 1;
      ctx.strokeRect(candleX, candleTop, candleW, candleHeight);
    }
  });
}

// Update Candlestick-Info
function updateCandlestickInfo(infoDiv, candle) {
  // Konvertiere Strings zu Numbers f√ºr toFixed()
  const open = parseFloat(candle.open);
  const high = parseFloat(candle.high);
  const low = parseFloat(candle.low);
  const close = parseFloat(candle.close);
  
  infoDiv.querySelector('.open-price').textContent = open.toFixed(2);
  infoDiv.querySelector('.high-price').textContent = high.toFixed(2);
  infoDiv.querySelector('.low-price').textContent = low.toFixed(2);
  infoDiv.querySelector('.close-price').textContent = close.toFixed(2);
}

// Erstelle individuelle Tooltips f√ºr jede Kerze
function createIndividualTooltips(container, candleCount) {
  console.log(`üïØÔ∏è Erstelle ${candleCount} individuelle Tooltips f√ºr Container:`, container);
  
  // Entferne alte Tooltips
  const oldTooltips = container.querySelectorAll('.candlestick-tooltip');
  console.log(`üîç Entferne ${oldTooltips.length} alte Tooltips`);
  oldTooltips.forEach(t => t.remove());
  
  // Erstelle Tooltips f√ºr jede Kerze
  for (let i = 0; i < candleCount; i++) {
    const tooltip = document.createElement('div');
    tooltip.className = `candlestick-tooltip candlestick-tooltip-${i} d-none`;
    tooltip.innerHTML = `
      <small>Kerze ${i + 1}: O: <span class="open-price">-</span></small><br>
      <small>H: <span class="high-price">-</span></small><br>
      <small>L: <span class="low-price">-</span></small><br>
      <small>C: <span class="close-price">-</span></small>
    `;
    container.appendChild(tooltip);
    console.log(`‚úÖ Tooltip ${i + 1} erstellt:`, tooltip.className);
  }
  
  // Verifiziere die erstellten Tooltips
  const newTooltips = container.querySelectorAll('.candlestick-tooltip');
  console.log(`‚úÖ ${newTooltips.length} individuelle Tooltips erstellt und verifiziert`);
  newTooltips.forEach((tooltip, index) => {
    console.log(`üîç Verifizierter Tooltip ${index + 1}:`, tooltip.className);
  });
}

// Zeige Tooltip f√ºr spezifische Kerze
function showTooltip(container, candleIndex, candleData) {
  console.log(`üïØÔ∏è Versuche Tooltip f√ºr Kerze ${candleIndex + 1} anzuzeigen`);
  
  const tooltip = container.querySelector(`.candlestick-tooltip-${candleIndex}`);
  console.log(`üîç Gefundener Tooltip:`, tooltip);
  
  if (tooltip && candleData) {
    updateIndividualTooltip(tooltip, candleData, candleIndex);
    tooltip.classList.remove('d-none');
    console.log(`‚úÖ Tooltip f√ºr Kerze ${candleIndex + 1} angezeigt`);
  } else {
    console.log(`‚ùå Tooltip nicht gefunden oder keine Daten f√ºr Kerze ${candleIndex + 1}`);
    if (!tooltip) {
      console.log(`üîç Verf√ºgbare Tooltips:`, container.querySelectorAll('.candlestick-tooltip').length);
    }
    if (!candleData) {
      console.log(`üîç Keine Candle-Daten f√ºr Index ${candleIndex}`);
    }
  }
}

// Verstecke alle Tooltips
function hideAllTooltips(container) {
  container.querySelectorAll('.candlestick-tooltip').forEach(tooltip => {
    tooltip.classList.add('d-none');
  });
}

// Update individuellen Tooltip mit Prozentwerten
function updateIndividualTooltip(tooltip, candle, candleIndex) {
  // Konvertiere Strings zu Numbers f√ºr Berechnungen
  const open = parseFloat(candle.open);
  const high = parseFloat(candle.high);
  const low = parseFloat(candle.low);
  const close = parseFloat(candle.close);
  
  // Berechne prozentuale √Ñnderungen
  const highChange = ((high - open) / open) * 100;
  const lowChange = ((low - open) / open) * 100;
  const closeChange = ((close - open) / open) * 100;
  
  // Update Tooltip mit Prozentwerten
  tooltip.querySelector('.open-price').textContent = open.toFixed(6);
  tooltip.querySelector('.high-price').textContent = `${high.toFixed(6)} (${highChange >= 0 ? '+' : ''}${highChange.toFixed(2)}%)`;
  tooltip.querySelector('.low-price').textContent = `${low.toFixed(6)} (${lowChange >= 0 ? '+' : ''}${lowChange.toFixed(2)}%)`;
  tooltip.querySelector('.close-price').textContent = `${close.toFixed(6)} (${closeChange >= 0 ? '+' : ''}${closeChange.toFixed(2)}%)`;
  
  console.log(`üïØÔ∏è Tooltip f√ºr Kerze ${candleIndex + 1} aktualisiert: Open=${open}, High=${high} (${highChange.toFixed(2)}%), Low=${low} (${lowChange.toFixed(2)}%), Close=${close} (${closeChange.toFixed(2)}%)`);
}

// Update Mini-Candlestick-Info mit Prozentwerten der letzten vollst√§ndigen Kerze (Legacy)
function updateMiniCandlestickInfo(infoDiv, candle) {
  // Konvertiere Strings zu Numbers f√ºr Berechnungen
  const open = parseFloat(candle.open);
  const high = parseFloat(candle.high);
  const low = parseFloat(candle.low);
  const close = parseFloat(candle.close);
  
  // Berechne prozentuale √Ñnderungen
  const highChange = ((high - open) / open) * 100;
  const lowChange = ((low - open) / open) * 100;
  const closeChange = ((close - open) / open) * 100;
  
  // Update Tooltip mit Prozentwerten
  infoDiv.querySelector('.open-price').textContent = open.toFixed(6);
  infoDiv.querySelector('.high-price').textContent = `${high.toFixed(6)} (${highChange >= 0 ? '+' : ''}${highChange.toFixed(2)}%)`;
  infoDiv.querySelector('.low-price').textContent = `${low.toFixed(6)} (${lowChange >= 0 ? '+' : ''}${lowChange.toFixed(2)}%)`;
  infoDiv.querySelector('.close-price').textContent = `${close.toFixed(6)} (${closeChange >= 0 ? '+' : ''}${closeChange.toFixed(2)}%)`;
  
  console.log(`üïØÔ∏è Mini-Candlestick-Tooltip aktualisiert: Open=${open}, High=${high} (${highChange.toFixed(2)}%), Low=${low} (${lowChange.toFixed(2)}%), Close=${close} (${closeChange.toFixed(2)}%)`);
}

// Update 1h Kerzen-Info mit Prozentwerten (letzte Kerze)
function update1hCandlesInfo(infoDiv, candles) {
  if (!candles || candles.length === 0) {
    console.log(`‚ö†Ô∏è Keine 1h Kerzen-Daten f√ºr Tooltip verf√ºgbar`);
    return;
  }
  
  // Verwende die letzte Kerze f√ºr den Tooltip
  const lastCandle = candles[candles.length - 1];
  
  // Konvertiere Strings zu Numbers f√ºr Berechnungen
  const open = parseFloat(lastCandle.open);
  const high = parseFloat(lastCandle.high);
  const low = parseFloat(lastCandle.low);
  const close = parseFloat(lastCandle.close);
  
  // Berechne prozentuale √Ñnderungen
  const highChange = ((high - open) / open) * 100;
  const lowChange = ((low - open) / open) * 100;
  const closeChange = ((close - open) / open) * 100;
  
  // Update Tooltip mit Prozentwerten
  infoDiv.querySelector('.open-price').textContent = open.toFixed(6);
  infoDiv.querySelector('.high-price').textContent = `${high.toFixed(6)} (${highChange >= 0 ? '+' : ''}${highChange.toFixed(2)}%)`;
  infoDiv.querySelector('.low-price').textContent = `${low.toFixed(6)} (${lowChange >= 0 ? '+' : ''}${lowChange.toFixed(2)}%)`;
  infoDiv.querySelector('.close-price').textContent = `${close.toFixed(6)} (${closeChange >= 0 ? '+' : ''}${closeChange.toFixed(2)}%)`;
  
  console.log(`üïØÔ∏è 1h Kerzen-Tooltip aktualisiert (letzte Kerze): Open=${open}, High=${high} (${highChange.toFixed(2)}%), Low=${low} (${lowChange.toFixed(2)}%), Close=${close} (${closeChange.toFixed(2)}%)`);
}

// Zeichne aktuelle 1h Kerzen (3 Kerzen)
function drawCurrent1hCandles(canvas, data) {
  console.log(`üïØÔ∏è drawCurrent1hCandles aufgerufen f√ºr Canvas:`, canvas);
  console.log(`üïØÔ∏è 1h Daten:`, data);
  
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  
  console.log(`üïØÔ∏è 1h Canvas-Dimensionen: ${width}x${height}`);
  
  // Clear canvas
  ctx.clearRect(0, 0, width, height);
  
  if (!data || data.length === 0) {
    console.log('‚ö†Ô∏è Keine 1h Kerzen-Daten verf√ºgbar - Chart bleibt leer');
    
    // Zeichne einen Platzhalter-Text
    ctx.fillStyle = '#6c757d';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Keine Daten', width / 2, height / 2);
    return;
  }
  
  // Verwende die letzten 3 Kerzen
  const candles = data.slice(-3);
  console.log(`üïØÔ∏è Zeichne ${candles.length} 1h Kerzen:`, candles);
  
  // Zeichne jede Kerze ohne prozentuale Skalierung
  const candleWidth = width / candles.length;
  const padding = 4;
  const availableWidth = width - (padding * 2);
  const availableHeight = height - (padding * 2);
  
  candles.forEach((candle, index) => {
    const x = index * candleWidth + padding;
    const candleX = x + candleWidth * 0.1;
    const candleW = candleWidth * 0.8;
    
    // Konvertiere Preise zu Numbers
    const openPrice = parseFloat(candle.open);
    const highPrice = parseFloat(candle.high);
    const lowPrice = parseFloat(candle.low);
    const closePrice = parseFloat(candle.close);
    
    // Finde min/max Preise f√ºr lokale Skalierung
    const allPrices = candles.flatMap(c => [parseFloat(c.low), parseFloat(c.high)]);
    const minPrice = Math.min(...allPrices);
    const maxPrice = Math.max(...allPrices);
    const priceRange = maxPrice - minPrice;
    
    if (priceRange === 0) {
      // Doji - nur horizontale Linie
      ctx.strokeStyle = candle.isGreen ? '#28a745' : '#dc3545';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(candleX, height / 2);
      ctx.lineTo(candleX + candleW, height / 2);
      ctx.stroke();
    } else {
      // Normale Kerze mit lokaler Skalierung
      // Skaliere Preise auf Canvas-H√∂he
      const highY = ((maxPrice - highPrice) / priceRange) * availableHeight + 2;
      const lowY = ((maxPrice - lowPrice) / priceRange) * availableHeight + 2;
      const openY = ((maxPrice - openPrice) / priceRange) * availableHeight + 2;
      const closeY = ((maxPrice - closePrice) / priceRange) * availableHeight + 2;
      
      // Zeichne Docht (High-Low Linie)
      ctx.strokeStyle = candle.isGreen ? '#28a745' : '#dc3545';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(candleX + candleW / 2, highY);
      ctx.lineTo(candleX + candleW / 2, lowY);
      ctx.stroke();
      
      // Zeichne Kerze (Open-Close Rechteck)
      const candleTop = Math.min(openY, closeY);
      const candleBottom = Math.max(openY, closeY);
      const candleBodyHeight = Math.abs(closeY - openY);
      
      if (candleBodyHeight === 0) {
        // Doji - nur horizontale Linie
        ctx.strokeStyle = candle.isGreen ? '#28a745' : '#dc3545';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(candleX, openY);
        ctx.lineTo(candleX + candleW, openY);
        ctx.stroke();
      } else {
        // Normale Kerze
        ctx.fillStyle = candle.isGreen ? '#28a745' : '#dc3545';
        ctx.fillRect(candleX, candleTop, candleW, candleBodyHeight);
        
        // Kerzen-Rand
        ctx.strokeStyle = candle.isGreen ? '#28a745' : '#dc3545';
        ctx.lineWidth = 1;
        ctx.strokeRect(candleX, candleTop, candleW, candleBodyHeight);
      }
    }
  });
  
  // Markiere verschiedene Zust√§nde der Kerzen
  canvas.classList.remove('incomplete', 'complete', 'old');
  
  // Pr√ºfe ob die letzte Kerze aus der aktuellen Stunde ist
  const lastCandle = candles[candles.length - 1];
  if (lastCandle.isCurrentHour) {
    if (!lastCandle.isComplete) {
      canvas.classList.add('incomplete'); // Aktuelle Stunde, noch nicht abgeschlossen
    } else {
      canvas.classList.add('complete'); // Aktuelle Stunde, abgeschlossen
    }
  } else {
    canvas.classList.add('old'); // √Ñltere Kerzen
  }
}

            // ActionCable f√ºr Live-Updates der Mini-Candlesticks und 1h Kerzen
            if (typeof App !== 'undefined' && App.cable) {
              const channel = App.cable.subscriptions.create("PricesChannel", {
                received(data) {
                  if (data.type === 'price') {
                    const container = document.querySelector(`[data-crypto-id="${data.cryptocurrency_id}"]`);
                    if (container) {
                      // Update Mini-Candlestick
                      const miniCanvas = container.querySelector('.mini-candlestick');
                      if (miniCanvas) {
                        updateMiniCandlestick(miniCanvas, data.price, data.cryptocurrency_id);
                      }
                      
                      // Update 1h Kerzen
                      const current1hCanvas = container.querySelector('.current-1h-candles');
                      if (current1hCanvas) {
                        updateCurrent1hCandles(current1hCanvas, data.price, data.cryptocurrency_id);
                      }
                    }
                  }
                }
              });
            }

            // Update Mini-Candlestick mit neuem Preis
            function updateMiniCandlestick(canvas, newPrice, cryptoId) {
              console.log(`üïØÔ∏è Update Mini-Candlestick f√ºr ${cryptoId}: $${newPrice}`);
              
              // Lade aktuelle Candlestick-Daten
              let candlestickData = loadRealCandlestickData(cryptoId);
              
              if (candlestickData.length > 0) {
                // Update die rechte Kerze (letzte) mit dem neuen Preis
                const lastCandle = candlestickData[candlestickData.length - 1];
                
                // Konvertiere zu Numbers f√ºr Vergleich
                const currentHigh = parseFloat(lastCandle.high);
                const currentLow = parseFloat(lastCandle.low);
                const currentOpen = parseFloat(lastCandle.open);
                const newPriceNum = parseFloat(newPrice);
                
                // Wenn der neue Preis h√∂her ist als der aktuelle High, update High
                if (newPriceNum > currentHigh) {
                  lastCandle.high = newPriceNum;
                }
                
                // Wenn der neue Preis niedriger ist als der aktuelle Low, update Low
                if (newPriceNum < currentLow) {
                  lastCandle.low = newPriceNum;
                }
                
                // Update Close-Preis
                lastCandle.close = newPriceNum;
                
                // Update isGreen basierend auf Open vs Close
                lastCandle.isGreen = newPriceNum > currentOpen;
                
                // Zeichne die aktualisierten Candlesticks
                drawMiniCandlesticks(canvas, candlestickData);
                
                console.log(`‚úÖ Mini-Candlestick aktualisiert f√ºr ${cryptoId}`);
              }
            }
            
            // Update aktuelle 1h Kerzen mit neuem Preis
            function updateCurrent1hCandles(canvas, newPrice, cryptoId) {
              console.log(`üïØÔ∏è Update 1h Kerzen f√ºr ${cryptoId}: $${newPrice}`);
              
              // Lade aktuelle 1h Kerzen-Daten
              let current1hData = loadCurrent1hCandlesData(cryptoId);
              
              if (current1hData && current1hData.length > 0) {
                // Update die letzte Kerze (aktuelle)
                const lastCandle = current1hData[current1hData.length - 1];
                
                // Konvertiere zu Numbers f√ºr Vergleich
                const currentHigh = parseFloat(lastCandle.high);
                const currentLow = parseFloat(lastCandle.low);
                const currentOpen = parseFloat(lastCandle.open);
                const newPriceNum = parseFloat(newPrice);
                
                // Wenn der neue Preis h√∂her ist als der aktuelle High, update High
                if (newPriceNum > currentHigh) {
                  lastCandle.high = newPriceNum;
                }
                
                // Wenn der neue Preis niedriger ist als der aktuelle Low, update Low
                if (newPriceNum < currentLow) {
                  lastCandle.low = newPriceNum;
                }
                
                // Update Close-Preis
                lastCandle.close = newPriceNum;
                
                // Update isGreen basierend auf Open vs Close
                lastCandle.isGreen = newPriceNum > currentOpen;
                
                // Zeichne die aktualisierten 1h Kerzen
                drawCurrent1hCandles(canvas, current1hData);
                
                console.log(`‚úÖ 1h Kerzen aktualisiert f√ºr ${cryptoId}`);
                
                // Zeichne alle 1h Kerzen neu, um gleichen Ma√üstab zu gew√§hrleisten
                setTimeout(() => {
                  redrawAll1hCandles();
                }, 100);
              }
            }

            // Update Mini-Candlestick mit neuen Candle-Daten vom Server
            function updateMiniCandlestickWithCandles(canvas, newCandles, cryptoId) {
              console.log(`üïØÔ∏è Update Mini-Candlestick mit Candle-Daten f√ºr ${cryptoId}:`, newCandles);
              
              if (newCandles && newCandles.length > 0) {
                // Zeichne die neuen Candlesticks direkt
                drawMiniCandlesticks(canvas, newCandles);
                
                // Update die Tooltips f√ºr die neuen Daten
                const container = canvas.closest('.mini-candlestick-container');
                if (container) {
                  createIndividualTooltips(container, newCandles.length);
                }
                
                console.log(`‚úÖ Mini-Candlestick mit Candle-Daten aktualisiert f√ºr ${cryptoId}`);
              }
            }

            // Behandle Candle-Updates von ActionCable
            function handleCandleUpdate(data) {
              console.log(`üïØÔ∏è Candle-Update erhalten f√ºr ${data.symbol}:`, data.candles);
              
              // Verhindere, dass 1m-Updates die Mini-Charts √ºberschreiben, wenn ein gr√∂√üerer Timeframe aktiv ist
              const tfEl = document.getElementById('timeframe-selector');
              const currentTimeframe = tfEl ? tfEl.value : '1m';
              if (currentTimeframe !== '1m') {
                console.log(`‚è≠Ô∏è √úberspringe Candle-Update (1m) ‚Äì aktueller Timeframe ist ${currentTimeframe}`);
                return;
              }
              console.log(`üîç Suche nach Container mit data-crypto-id="${data.cryptocurrency_id}"`);
              
              // Debug: Zeige alle verf√ºgbaren data-crypto-id Attribute
              const allContainers = document.querySelectorAll('[data-crypto-id]');
              console.log(`üîç Verf√ºgbare data-crypto-id Attribute:`, Array.from(allContainers).map(c => c.getAttribute('data-crypto-id')));
              
              // Update die gecachten Daten
              updateCandlestickDataCache(data.cryptocurrency_id, data.candles);
              
              const container = document.querySelector(`[data-crypto-id="${data.cryptocurrency_id}"]`);
              if (container) {
                console.log(`‚úÖ Container gefunden f√ºr ${data.symbol}`);
                const canvas = container.querySelector('.mini-candlestick');
                if (canvas) {
                  console.log(`‚úÖ Canvas gefunden f√ºr ${data.symbol}`);
                  // Update Mini-Candlestick mit neuen Candle-Daten
                  updateMiniCandlestickWithCandles(canvas, data.candles, data.cryptocurrency_id);
                } else {
                  console.log(`[!] Mini-Candlestick Canvas nicht gefunden f√ºr ${data.symbol}`);
                }
              } else {
                console.log(`[!] Container nicht gefunden f√ºr Crypto ID: ${data.cryptocurrency_id} (${data.symbol})`);
              }
            }
            
            // Funktion zum Aktualisieren der Mini-Candlesticks mit neuem Timeframe
            function refreshMiniCandlesticks(timeframe) {
              console.log(`üïØÔ∏è Aktualisiere Mini-Candlesticks f√ºr Timeframe: ${timeframe}`);
              
              // Lade neue Candle-Daten vom Server f√ºr alle Cryptos
              fetch(`/cryptocurrencies/mini_candlestick_data?timeframe=${timeframe}`)
                .then(response => response.json())
                .then(data => {
                  console.log(`üìä Neue Candle-Daten erhalten f√ºr ${Object.keys(data).length} Cryptos`);
                  
                  // Update die gecachten Daten
                  Object.keys(data).forEach(cryptoId => {
                    updateCandlestickDataCache(cryptoId, data[cryptoId] || []);
                  });
                  
                  // Update alle Mini-Candlesticks
                  const candlestickCanvases = document.querySelectorAll('.mini-candlestick');
                  candlestickCanvases.forEach(canvas => {
                    const cryptoId = canvas.dataset.cryptoId;
                    const candlestickData = data[cryptoId] || [];
                    
                    if (candlestickData.length > 0) {
                      drawMiniCandlesticks(canvas, candlestickData);
                      console.log(`‚úÖ Mini-Candlestick aktualisiert f√ºr ${cryptoId} mit ${candlestickData.length} Kerzen`);
                    } else {
                      console.log(`‚ö†Ô∏è Keine aktuellen Daten f√ºr ${cryptoId} - zeichne leeren Chart`);
                      drawMiniCandlesticks(canvas, []);
                    }
                  });
                })
                .catch(error => {
                  console.error('‚ùå Fehler beim Laden der Mini-Candlestick-Daten:', error);
                });
            }
            
            // Starte automatischen Refresh f√ºr 1h Kerzen (jede Minute)
            setInterval(() => {
              refreshCurrent1hCandles();
            }, 60 * 1000); // 1 Minute

            // Starte automatischen Refresh f√ºr Mini-Candlesticks des aktuell ausgew√§hlten Timeframes (jede Minute)
            setInterval(() => {
              try {
                const tfEl = document.getElementById('timeframe-selector');
                const tf = tfEl ? tfEl.value : '1m';
                refreshMiniCandlesticks(tf);
              } catch (e) {
                console.error('‚ùå Fehler beim periodischen Mini-Candlestick-Refresh:', e);
              }
            }, 60 * 1000); // 1 Minute
            
            // Initialer Refresh der Mini-Candlesticks und 1h Kerzen nach 2 Sekunden
            setTimeout(() => {
              console.log('üïØÔ∏è Initialer Refresh von Mini-Candlesticks und 1h Kerzen...');
              // Mini-Candlesticks (aktueller Timeframe)
              try {
                const tfEl = document.getElementById('timeframe-selector');
                const tf = tfEl ? tfEl.value : '1m';
                refreshMiniCandlesticks(tf);
              } catch (e) {
                console.error('‚ùå Fehler beim initialen Mini-Candlestick-Refresh:', e);
              }
              
              // Debug: Zeige alle 1h Kerzen-Canvases
              const current1hCanvases = document.querySelectorAll('.current-1h-candles');
              console.log(`üîç Gefundene 1h Kerzen-Canvases: ${current1hCanvases.length}`);
              current1hCanvases.forEach((canvas, index) => {
                console.log(`üîç Canvas ${index}:`, canvas);
                console.log(`üîç Crypto ID:`, canvas.dataset.cryptoId);
              });
              
              // Debug: Zeige Cache-Daten
              console.log(`üîç 1h Kerzen-Cache:`, current1hCandlesCache);
              console.log(`üîç Mini-Candlestick-Cache:`, candlestickDataCache);
              
              // Lade echte 1h Kerzen-Daten vom Server
              refreshCurrent1hCandles();
            }, 2000);
            
            // Test der DataTable-Initialisierung nach 3 Sekunden
            setTimeout(() => {
              console.log('üîç Teste DataTable-Initialisierung...');
              checkDataTableInitialization();
              
              // Test der Neusortierung nach 5 Sekunden
              setTimeout(() => {
                console.log(`üß™ Teste Neusortierung...`);
                forceResortWithRetry();
              }, 2000);
            }, 3000);
            
            // Entfernt: fr√ºherer Test-Block, der 1h-Canvas √ºberschrieben hat
            
            // Test der Mini-Candlestick Tooltips nach 2 Sekunden
            setTimeout(() => {
              console.log('üïØÔ∏è Teste Mini-Candlestick Tooltips...');
              
              const miniContainers = document.querySelectorAll('.mini-candlestick-container');
              console.log(`üîç Test: Gefundene Mini-Container: ${miniContainers.length}`);
              
              miniContainers.forEach((container, index) => {
                const tooltips = container.querySelectorAll('.candlestick-tooltip');
                console.log(`üîç Container ${index}: ${tooltips.length} Tooltips gefunden`);
                
                tooltips.forEach((tooltip, tooltipIndex) => {
                  console.log(`üîç Tooltip ${tooltipIndex}:`, tooltip.className);
                });
              });
            }, 2000);
            
            // Funktion zum Neuziehen aller 1h Kerzen (nur echte Cache-Daten benutzen)
            function redrawAll1hCandles() {
              console.log(`üïØÔ∏è Zeichne alle 1h Kerzen neu`);
              const current1hCanvases = document.querySelectorAll('.current-1h-candles');
              current1hCanvases.forEach(canvas => {
                const cryptoId = canvas.dataset.cryptoId;
                const data = current1hCandlesCache[cryptoId] || [];
                if (data && data.length > 0) {
                  drawCurrent1hCandles(canvas, data);
                  console.log(`‚úÖ 1h Kerzen neu gezeichnet f√ºr ${cryptoId}`);
                }
              });
            }
            
            // Funktion zum Wiederanwenden der aktuellen Sortierung
            function reapplyCurrentSort() {
              console.log(`üîÑ Wende aktuelle Sortierung erneut an`);
              
              // Warte kurz, damit DOM-Updates abgeschlossen sind
              setTimeout(() => {
                try {
                  const table = $('#crypto-table').DataTable();
                  console.log(`üîç DataTable gefunden:`, table);
                  
                  if (table) {
                    // Hole aktuelle Sortierung
                    const currentOrder = table.order();
                    console.log(`üîç Aktuelle Sortierung:`, currentOrder);
                    
                    if (currentOrder && currentOrder.length > 0) {
                      console.log(`üîÑ Aktuelle Sortierung: Spalte ${currentOrder[0][0]}, Richtung: ${currentOrder[0][1]}`);
                      
                      // Debug: Zeige data-sort Attribute f√ºr alle Zeilen
                      debugDataSortAttributes();
                      
                      // Wende Sortierung erneut an
                      table.order(currentOrder).draw();
                      console.log(`‚úÖ Sortierung erfolgreich wieder angewendet`);
                    } else {
                      console.log(`‚ö†Ô∏è Keine aktuelle Sortierung gefunden, verwende Standard-Sortierung`);
                      // Verwende Standard-Sortierung (RSI aufsteigend)
                      table.order([7, 'asc']).draw();
                      console.log(`‚úÖ Standard-Sortierung angewendet`);
                    }
                  } else {
                    console.log(`‚ö†Ô∏è DataTable nicht gefunden, versuche erneut...`);
                    
                    // Versuche DataTable erneut zu initialisieren
                    setTimeout(() => {
                      const retryTable = $('#crypto-table').DataTable();
                      if (retryTable) {
                        console.log(`‚úÖ DataTable bei Wiederholung gefunden`);
                        retryTable.order([7, 'asc']).draw();
                        console.log(`‚úÖ Sortierung nach Wiederholung angewendet`);
                      } else {
                        console.log(`‚ùå DataTable auch bei Wiederholung nicht gefunden`);
                      }
                    }, 200);
                  }
                } catch (error) {
                  console.error(`‚ùå Fehler bei der Neusortierung:`, error);
                  
                  // Fallback: Versuche manuelle Sortierung
                  try {
                    const table = $('#crypto-table').DataTable();
                    if (table) {
                      table.order([7, 'asc']).draw();
                      console.log(`‚úÖ Fallback-Sortierung angewendet`);
                    }
                  } catch (fallbackError) {
                    console.error(`‚ùå Auch Fallback-Sortierung fehlgeschlagen:`, fallbackError);
                  }
                }
              }, 50); // Kurze Verz√∂gerung f√ºr DOM-Updates
            }
            
            // Funktion zum Debuggen der data-sort Attribute
            function debugDataSortAttributes() {
              console.log(`üîç Debug data-sort Attribute:`);
              
              const rows = document.querySelectorAll('#crypto-table tbody tr');
              rows.forEach((row, index) => {
                const rsiCell = row.cells[7];
                const rocCell = row.cells[8];
                const rocDerivativeCell = row.cells[9];
                
                if (rsiCell) {
                  const rsiSort = rsiCell.getAttribute('data-sort');
                  const rsiText = rsiCell.textContent.trim();
                  console.log(`üìä Zeile ${index}: RSI data-sort="${rsiSort}", Text="${rsiText}"`);
                }
                
                if (rocCell) {
                  const rocSort = rocCell.getAttribute('data-sort');
                  const rocText = rocCell.textContent.trim();
                  console.log(`üìä Zeile ${index}: ROC data-sort="${rocSort}", Text="${rocText}"`);
                }
                
                if (rocDerivativeCell) {
                  const rocDerivativeSort = rocDerivativeCell.getAttribute('data-sort');
                  const rocDerivativeText = rocDerivativeCell.textContent.trim();
                  console.log(`üìä Zeile ${index}: ROC' data-sort="${rocDerivativeSort}", Text="${rocDerivativeText}"`);
                }
              });
            }
            
            // Funktion zum √úberpr√ºfen der DataTable-Initialisierung
            function checkDataTableInitialization() {
              console.log(`üîç √úberpr√ºfe DataTable-Initialisierung:`);
              
              const tableElement = document.getElementById('crypto-table');
              console.log(`üîç Table-Element gefunden:`, !!tableElement);
              
              if (tableElement) {
                console.log(`üîç Table-Element ID:`, tableElement.id);
                console.log(`üîç Table-Element Klassen:`, tableElement.className);
              }
              
              // Versuche DataTable zu finden
              let table = null;
              try {
                table = $('#crypto-table').DataTable();
                console.log(`‚úÖ DataTable gefunden:`, !!table);
                
                if (table) {
                  console.log(`üîç DataTable Einstellungen:`, {
                    order: table.order(),
                    page: table.page(),
                    info: table.page.info()
                  });
                }
              } catch (error) {
                console.log(`‚ùå DataTable nicht gefunden:`, error.message);
              }
              
              // √úberpr√ºfe jQuery
              console.log(`üîç jQuery verf√ºgbar:`, typeof $ !== 'undefined');
              console.log(`üîç DataTables Plugin verf√ºgbar:`, typeof $.fn.DataTable !== 'undefined');
            }
            
            // Funktion zum Erzwingen der Neusortierung
            function forceResort() {
              console.log(`üîÑ Erzwinge Neusortierung...`);
              
              setTimeout(() => {
                try {
                  const table = $('#crypto-table').DataTable();
                  if (table) {
                    // Hole aktuelle Sortierung oder verwende Standard
                    const currentOrder = table.order();
                    const orderToApply = (currentOrder && currentOrder.length > 0) ? currentOrder : [[7, 'asc']];
                    
                    console.log(`üîÑ Wende Sortierung an:`, orderToApply);
                    table.order(orderToApply).draw();
                    console.log(`‚úÖ Neusortierung erzwungen`);
                  } else {
                    console.log(`‚ùå DataTable nicht verf√ºgbar f√ºr erzwungene Neusortierung`);
                  }
                } catch (error) {
                  console.error(`‚ùå Fehler bei erzwungener Neusortierung:`, error);
                }
              }, 100);
            }
            
            // Funktion zum Erzwingen der Neusortierung mit mehreren Versuchen
            function forceResortWithRetry() {
              console.log(`üîÑ Erzwinge Neusortierung mit Wiederholung...`);
              
              let attempts = 0;
              const maxAttempts = 5;
              
              const attemptResort = () => {
                attempts++;
                console.log(`üîÑ Versuch ${attempts} von ${maxAttempts}`);
                
                try {
                  // Versuche verschiedene Wege, die DataTable zu finden
                  let table = null;
                  
                  // Methode 1: Direkter DataTable-Zugriff
                  try {
                    table = $('#crypto-table').DataTable();
                  } catch (e) {
                    console.log(`‚ö†Ô∏è DataTable direkter Zugriff fehlgeschlagen:`, e.message);
                  }
                  
                  // Methode 2: √úber jQuery
                  if (!table) {
                    try {
                      table = $($('#crypto-table')).DataTable();
                    } catch (e) {
                      console.log(`‚ö†Ô∏è DataTable jQuery-Zugriff fehlgeschlagen:`, e.message);
                    }
                  }
                  
                  // Methode 3: √úber DOM-Element
                  if (!table) {
                    try {
                      const tableElement = document.getElementById('crypto-table');
                      if (tableElement) {
                        table = $(tableElement).DataTable();
                      }
                    } catch (e) {
                      console.log(`‚ö†Ô∏è DataTable DOM-Zugriff fehlgeschlagen:`, e.message);
                    }
                  }
                  
                  if (table) {
                    console.log(`‚úÖ DataTable gefunden in Versuch ${attempts}`);
                    
                    // Hole aktuelle Sortierung oder verwende Standard
                    const currentOrder = table.order();
                    console.log(`üîç Aktuelle Sortierung:`, currentOrder);
                    
                    let orderToApply;
                    if (currentOrder && currentOrder.length > 0) {
                      orderToApply = currentOrder;
                      console.log(`üîÑ Verwende aktuelle Sortierung:`, orderToApply);
                    } else {
                      orderToApply = [[7, 'asc']]; // RSI aufsteigend als Standard
                      console.log(`üîÑ Verwende Standard-Sortierung:`, orderToApply);
                    }
                    
                    // Debug: Zeige alle data-sort Attribute vor der Sortierung
                    debugDataSortAttributes();
                    
                    // Wende Sortierung an
                    table.order(orderToApply).draw();
                    console.log(`‚úÖ Neusortierung erfolgreich nach ${attempts} Versuchen`);
                    
                    // Debug: Zeige alle data-sort Attribute nach der Sortierung
                    setTimeout(() => {
                      console.log(`üîç Nach der Sortierung:`);
                      debugDataSortAttributes();
                    }, 100);
                    
                    return true;
                  } else {
                    console.log(`‚ùå DataTable nicht verf√ºgbar (Versuch ${attempts})`);
                    return false;
                  }
                } catch (error) {
                  console.error(`‚ùå Fehler bei erzwungener Neusortierung (Versuch ${attempts}):`, error);
                  return false;
                }
              };
              
              // Erster Versuch sofort
              if (!attemptResort() && attempts < maxAttempts) {
                // Zweiter Versuch nach 100ms
                setTimeout(() => {
                  if (!attemptResort() && attempts < maxAttempts) {
                    // Dritter Versuch nach weiteren 200ms
                    setTimeout(() => {
                      if (!attemptResort() && attempts < maxAttempts) {
                        // Vierter Versuch nach weiteren 300ms
                        setTimeout(() => {
                          if (!attemptResort() && attempts < maxAttempts) {
                            // F√ºnfter Versuch nach weiteren 500ms
                            setTimeout(() => {
                              attemptResort();
                            }, 500);
                          }
                        }, 300);
                      }
                    }, 200);
                  }
                }, 100);
              }
            }
            
            // Funktion zum manuellen Erzwingen der Sortierung (Fallback)
            function forceManualSort() {
              console.log(`üîÑ Erzwinge manuelle Sortierung...`);
              
              try {
                const table = $('#crypto-table').DataTable();
                if (table) {
                  // Hole alle Zeilen
                  const rows = table.rows().nodes();
                  console.log(`üîç Anzahl Zeilen:`, rows.length);
                  
                  // Sortiere nach RSI (Spalte 7)
                  const sortedRows = Array.from(rows).sort((a, b) => {
                    const aRsi = parseFloat(a.cells[7].getAttribute('data-sort') || '0');
                    const bRsi = parseFloat(b.cells[7].getAttribute('data-sort') || '0');
                    return aRsi - bRsi; // Aufsteigend
                  });
                  
                  console.log(`üîÑ Manuell sortierte Zeilen:`, sortedRows.length);
                  
                  // Entferne alle Zeilen und f√ºge sie sortiert wieder hinzu
                  table.clear();
                  sortedRows.forEach(row => {
                    table.row.add(row);
                  });
                  table.draw();
                  
                  console.log(`‚úÖ Manuelle Sortierung abgeschlossen`);
                } else {
                  console.log(`‚ùå DataTable nicht verf√ºgbar f√ºr manuelle Sortierung`);
                }
              } catch (error) {
                console.error(`‚ùå Fehler bei manueller Sortierung:`, error);
              }
            }
            
            // Funktion zum Aktualisieren der 1h Kerzen
            function refreshCurrent1hCandles() {
              console.log(`üïØÔ∏è Aktualisiere 1h Kerzen`);
              
              // Lade echte 1h Kerzen-Daten vom Server
              fetch('/cryptocurrencies/current_1h_candle_data')
                .then(response => response.json())
                .then(data => {
                  console.log(`üìä Neue 1h Kerzen-Daten erhalten f√ºr ${Object.keys(data).length} Cryptos`);
                  
                  // Update die gecachten Daten
                  Object.keys(data).forEach(cryptoId => {
                    current1hCandlesCache[cryptoId] = data[cryptoId] || [];
                  });
                  
                  // Update alle 1h Kerzen
                  const current1hCanvases = document.querySelectorAll('.current-1h-candles');
                  current1hCanvases.forEach(canvas => {
                    const cryptoId = canvas.dataset.cryptoId;
                    const current1hData = data[cryptoId] || [];
                    
                    if (current1hData.length > 0) {
                      drawCurrent1hCandles(canvas, current1hData);
                      console.log(`‚úÖ 1h Kerzen aktualisiert f√ºr ${cryptoId} mit ${current1hData.length} Kerzen`);
                    } else {
                      console.log(`‚ö†Ô∏è Keine 1h Daten f√ºr ${cryptoId} - zeichne leeren Chart`);
                      drawCurrent1hCandles(canvas, null);
                    }
                  });
                })
                .catch(error => {
                  console.error('‚ùå Fehler beim Laden der 1h Kerzen-Daten:', error);
                });
            }


</script> 