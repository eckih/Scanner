<script>
console.log("üîß Direct ActionCable Test startet...");
console.log("üîß window.ActionCable:", typeof window.ActionCable);

document.addEventListener('DOMContentLoaded', function() {
  console.log("üîß DOM loaded - ActionCable Test");
  console.log("üîß window.ActionCable nach DOM load:", typeof window.ActionCable);
  
  // Funktion zum Warten auf ActionCable
  function waitForActionCable(maxAttempts = 20) {
    return new Promise((resolve, reject) => {
      let attempts = 0;
      
      function check() {
        attempts++;
        console.log(`üîß ActionCable Check Versuch ${attempts}:`, typeof window.ActionCable);
        
        if (typeof window.ActionCable !== 'undefined') {
          console.log("üéâ ActionCable gefunden nach", attempts, "Versuchen!");
          resolve();
        } else if (attempts >= maxAttempts) {
          console.log("‚ùå ActionCable nach", attempts, "Versuchen nicht gefunden");
          reject(new Error("ActionCable nicht verf√ºgbar"));
        } else {
          setTimeout(check, 200); // Alle 200ms pr√ºfen
        }
      }
      
      check();
    });
  }
  
  // Warte auf ActionCable und starte dann die Verbindung
  waitForActionCable().then(() => {
    console.log("üîß ActionCable ist verf√ºgbar, starte Verbindung...");
    
    if (typeof window.ActionCable !== 'undefined') {
      console.log("üéâ ActionCable gefunden! Erstelle Verbindung...");
      
      // WebSocket URL bestimmen
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const host = window.location.host;
      const wsUrl = `${protocol}//${host}/cable`;
      
      console.log("üîå WebSocket URL:", wsUrl);
      
      // Consumer erstellen
      const consumer = ActionCable.createConsumer(wsUrl);
      console.log("üîå Consumer erstellt:", consumer);
      
      // PricesChannel subscription
      const subscription = consumer.subscriptions.create("PricesChannel", {
        connected() {
          console.log("üéâ ERFOLGREICH mit PricesChannel verbunden!");
        },
        
        disconnected() {
          console.log("‚ùå Von PricesChannel getrennt");
        },
        
        rejected() {
          console.log("üö´ PricesChannel Subscription abgelehnt");
        },
        
                              received(data) {
               // Debug: Zeige die vollst√§ndige Nachrichtenstruktur
               console.log("üì® Rohe ActionCable-Nachricht:", data);
               console.log("üì® Nachrichtentyp:", typeof data);
               console.log("üì® Nachricht hat message:", 'message' in data);
               
               // ActionCable-Nachrichten sind oft in einem 'message'-Objekt verschachtelt
               const messageData = data.message || data; // Nutze data.message, falls vorhanden, sonst direkt data
               console.log("üì® Verarbeitete Nachrichtendaten:", messageData);
               console.log("üîç Update-Type:", messageData.update_type);
               
               // Behandle Z√§hler-Updates zuerst (diese haben keine cryptocurrency_id)
               if (messageData.update_type === 'counters') {
                 console.log("üìä Z√§hler-Update erhalten:", messageData);
                 handleCounterUpdate(messageData);
                 return;
               }
               
               // Ignoriere Nachrichten ohne cryptocurrency_id oder symbol (au√üer Z√§hler-Updates)
               if (!messageData.cryptocurrency_id || !messageData.symbol) {
                 console.log("[!] Nachricht ohne cryptocurrency_id oder symbol ignoriert:", messageData);
                 return;
               }

               // Behandle verschiedene Update-Typen
               if (messageData.update_type === 'rsi') {
                 console.log("üìä RSI-Update erhalten:", messageData);
                 handleRsiUpdate(messageData);
                 return;
               }
               
               if (messageData.update_type === 'indicator') {
                 console.log("üìä Indikator-Update erhalten:", messageData);
                 handleIndicatorUpdate(messageData);
                 return;
               }
               
               // Behandle Candle-Updates
               if (messageData.type === 'candle_update') {
                 console.log("üïØÔ∏è Candle-Update erhalten:", messageData);
                 console.log("üïØÔ∏è Candle-Update Details:", {
                   symbol: messageData.symbol,
                   cryptoId: messageData.cryptocurrency_id,
                   candlesCount: messageData.candles ? messageData.candles.length : 0,
                   candles: messageData.candles
                 });
                 handleCandleUpdate(messageData);
                 return;
               }
               
               // Unterscheide zwischen Echtzeit-Updates und abgeschlossenen Kerzen (f√ºr Preis-Updates)
               const updateType = messageData.realtime ? "üöÄ ECHTZEIT" : "üìä KERZE";
               console.log(`üì® ${updateType} Preis-Update erhalten:`, messageData);
               
               // DOM Update
               // DEBUG: Zeige verf√ºgbare data-crypto-id Attribute
               const allRows = document.querySelectorAll('[data-crypto-id]');
               console.log("üîç Verf√ºgbare data-crypto-id:", Array.from(allRows).map(r => r.getAttribute('data-crypto-id')));
               console.log("üéØ Suche nach ID:", messageData.cryptocurrency_id);
               
               const row = document.querySelector(`[data-crypto-id='${messageData.cryptocurrency_id}']`);
               if (row) {
                 console.log(`üéØ Zeile gefunden f√ºr Crypto ID: ${messageData.cryptocurrency_id} (${messageData.symbol})`);
                 
                 // Preis-Update
                 const priceCell = row.querySelector('.price-cell');
                 if (priceCell) {
                   const price = parseFloat(messageData.price);
                   const formattedPrice = price >= 1 ? `$${price.toFixed(2)}` : `$${price.toFixed(6)}`;
                   
                   // Erstelle oder aktualisiere den Link
                   let priceLink = priceCell.querySelector('a');
                   if (priceLink) {
                     // Link existiert bereits, nur Text aktualisieren
                     priceLink.textContent = formattedPrice;
                   } else {
                     // Kein Link vorhanden (war N/A), erstelle neuen Link
                     priceCell.innerHTML = `<a href="/cryptocurrencies/${messageData.cryptocurrency_id}/chart" target="_blank" class="text-decoration-none text-primary chart-link" title="Chart anzeigen">${formattedPrice}</a>`;
                   }
                   console.log(`üí∞ ${updateType} Preis aktualisiert: ${formattedPrice} (${messageData.symbol})`);
                   
                   // Verschiedene Animationen f√ºr verschiedene Update-Typen
                   if (messageData.realtime) {
                     // Subtile Animation f√ºr Echtzeit-Updates (h√§ufig)
                     priceCell.style.transition = 'background-color 0.15s ease';
                     priceCell.style.backgroundColor = '#e3f2fd'; // Hellblau f√ºr Echtzeit
                     setTimeout(() => {
                       priceCell.style.backgroundColor = '';
                     }, 150);
                   } else {
                     // Auff√§lligere Animation f√ºr abgeschlossene Kerzen (seltener)
                     priceCell.style.transition = 'background-color 0.5s ease';
                     priceCell.style.backgroundColor = '#d4edda'; // Gr√ºn f√ºr abgeschlossene Kerzen
                     setTimeout(() => {
                       priceCell.style.backgroundColor = '';
                     }, 500);
                   }
                 } else {
                   console.log(`[!] Preis-Zelle nicht gefunden f√ºr ${messageData.symbol}`);
                 }
                 
                 // 24h √Ñnderung Update (nur bei abgeschlossenen Kerzen)
                 if (messageData.candle_closed && messageData.price_change_24h !== undefined) {
                   const change24hCell = row.querySelector('td:nth-child(5)'); // 5. Spalte ist "24h √Ñnderung"
                   if (change24hCell) {
                     const change24h = parseFloat(messageData.price_change_24h);
                     const formattedChange = messageData.price_change_24h_formatted || 
                       (change24h >= 0 ? `+${change24h.toFixed(2)}%` : `${change24h.toFixed(2)}%`);
                     
                     // Bestimme die Farbe basierend auf Wert und Vollst√§ndigkeit
                     let colorClass = 'text-danger'; // Standard: rot f√ºr unvollst√§ndige Daten
                     
                     if (messageData.price_change_24h_complete === true) {
                       // Vollst√§ndige 24h Daten - normale Farben
                       colorClass = change24h >= 0 ? 'text-success' : 'text-danger';
                     } else {
                       // Unvollst√§ndige Daten - immer rot (wie bei 0.00)
                       colorClass = 'text-danger';
                     }
                     
                     // Aktualisiere den Text und die Farbe
                     change24hCell.innerHTML = `
                       <span class="${colorClass}">
                         ${change24h >= 0 ? '<i class="bi bi-arrow-up"></i>' : '<i class="bi bi-arrow-down"></i>'}
                         ${formattedChange}
                       </span>
                     `;
                     
                     const updateType = messageData.price_change_24h_complete ? "üìà 24h √Ñnderung (vollst√§ndig)" : "[!] 24h √Ñnderung (unvollst√§ndig)";
                     console.log(`${updateType} aktualisiert: ${formattedChange} (${messageData.symbol})`);
                     
                     // Animation f√ºr 24h √Ñnderung
                     change24hCell.style.transition = 'background-color 0.5s ease';
                     change24hCell.style.backgroundColor = colorClass === 'text-success' ? '#d4edda' : '#f8d7da';
                     setTimeout(() => {
                       change24hCell.style.backgroundColor = '';
                     }, 500);
                   }
                 }
                 
                 // Market Cap Update (nur bei abgeschlossenen Kerzen)
                 if (messageData.candle_closed && messageData.market_cap !== undefined) {
                   const marketCapCell = row.querySelector('td:nth-child(6)'); // 6. Spalte ist "Market Cap"
                   if (marketCapCell) {
                     const marketCap = messageData.market_cap_formatted || 'N/A';
                     marketCapCell.textContent = marketCap;
                     
                     console.log(`üìä Market Cap aktualisiert: ${marketCap} (${messageData.symbol})`);
                     
                     // Animation f√ºr Market Cap
                     marketCapCell.style.transition = 'background-color 0.5s ease';
                     marketCapCell.style.backgroundColor = '#e3f2fd'; // Hellblau f√ºr Market Cap
                     setTimeout(() => {
                       marketCapCell.style.backgroundColor = '';
                     }, 500);
                   }
                 }
                 
                 // Volume 24h Update (nur bei abgeschlossenen Kerzen)
                 if (messageData.candle_closed && messageData.volume_24h !== undefined) {
                   const volumeCell = row.querySelector('td:nth-child(7)'); // 7. Spalte ist "Volumen 24h"
                   if (volumeCell) {
                     const volume = messageData.volume_24h_formatted || 'N/A';
                     volumeCell.textContent = volume;
                     
                     console.log(`üìà Volume 24h aktualisiert: ${volume} (${messageData.symbol})`);
                     
                     // Animation f√ºr Volume
                     volumeCell.style.transition = 'background-color 0.5s ease';
                     volumeCell.style.backgroundColor = '#fff3cd'; // Hellgelb f√ºr Volume
                     setTimeout(() => {
                       volumeCell.style.backgroundColor = '';
                     }, 500);
                   }
                 }
               } else {
                 console.log(`‚ùå Keine Zeile gefunden f√ºr Crypto ID: ${messageData.cryptocurrency_id} (${messageData.symbol})`);
                 console.log("üîç Verf√ºgbare Zeilen:", Array.from(document.querySelectorAll('[data-crypto-id]')).map(r => ({
                   id: r.getAttribute('data-crypto-id'),
                   symbol: r.querySelector('td:first-child')?.textContent?.trim()
                 })));
               }
             }
      });
      
      console.log("üì° Subscription erstellt:", subscription);
      
         } else {
       console.error("‚ùå ActionCable nicht verf√ºgbar!");
     }
   }).catch((error) => {
     console.error("‚ùå Fehler beim Laden von ActionCable:", error);
   });

 // Funktion zum Behandeln von RSI-Updates
 function handleRsiUpdate(data) {
   console.log("üìä Verarbeite RSI-Update f√ºr", data.symbol, ":", data.rsi);
   console.log("üîç Suche nach Crypto ID:", data.cryptocurrency_id);
   
   // Debug: Zeige alle verf√ºgbaren data-crypto-id Attribute
   const allRows = document.querySelectorAll('[data-crypto-id]');
   console.log("üîç Verf√ºgbare data-crypto-id:", Array.from(allRows).map(r => ({
     id: r.getAttribute('data-crypto-id'),
     symbol: r.querySelector('td span.badge')?.textContent?.trim()
   })));
   
   const row = document.querySelector(`[data-crypto-id='${data.cryptocurrency_id}']`);
   if (!row) {
     console.log("[!] Zeile nicht gefunden f√ºr Crypto ID:", data.cryptocurrency_id);
     console.log("üîç Versuche Symbol-basierte Suche f√ºr:", data.symbol);
     
     // Fallback: Suche nach Symbol
     const searchSymbol = data.symbol.replace('USDC', '').replace('USDT', '');
     const allTableRows = document.querySelectorAll('tbody tr');
     let foundRow = null;
     
     for (const tableRow of allTableRows) {
       const symbolCell = tableRow.querySelector('td span.badge');
       if (symbolCell && symbolCell.textContent.trim() === searchSymbol) {
         foundRow = tableRow;
         console.log("‚úÖ Zeile gefunden √ºber Symbol-Matching:", data.symbol, "->", searchSymbol);
         break;
       }
     }
     
     if (!foundRow) {
       console.log("‚ùå Keine Zeile gefunden f√ºr Symbol:", data.symbol);
       return;
     }
     
         // Verwende die gefundene Zeile
    const rsiCell = foundRow.querySelector('.rsi-cell');
    if (rsiCell) {
      const rsiValue = parseFloat(data.rsi);
      console.log("üîç RSI-Zelle gefunden, aktualisiere Wert:", rsiValue.toFixed(2));
      rsiCell.textContent = rsiValue.toFixed(2);
      
      // Aktualisiere data-sort Attribut f√ºr korrekte Sortierung
      const rsiTd = rsiCell.closest('td');
      if (rsiTd) {
        rsiTd.setAttribute('data-sort', rsiValue);
        console.log("üìä data-sort Attribut aktualisiert:", rsiValue);
      }
      
      // RSI-Farbe basierend auf Wert
      rsiCell.className = 'badge rsi-cell';
      if (rsiValue >= 70) {
        rsiCell.classList.add('rsi-overbought'); // √úberkauft
      } else if (rsiValue <= 30) {
        rsiCell.classList.add('rsi-oversold'); // √úberverkauft  
      } else {
        rsiCell.classList.add('rsi-neutral'); // Neutral
      }
      
      // Animation f√ºr RSI-Update
      rsiCell.style.transition = 'background-color 0.8s ease';
      rsiCell.style.backgroundColor = '#fff3cd'; // Gelber Hintergrund
      setTimeout(() => {
        rsiCell.style.backgroundColor = '';
      }, 800);
      
      console.log("‚úÖ RSI-Update abgeschlossen f√ºr:", data.symbol, "- Wert:", rsiValue.toFixed(2));
    } else {
      console.log("[!] RSI-Zelle nicht gefunden in Symbol-basierter Zeile");
      console.log("üîç Zeilen-HTML:", foundRow.innerHTML);
    }
     return;
   }
   
     const rsiCell = row.querySelector('.rsi-cell');
  if (rsiCell) {
    const rsiValue = parseFloat(data.rsi);
    console.log("üîç RSI-Zelle gefunden, aktualisiere Wert:", rsiValue.toFixed(2));
    rsiCell.textContent = rsiValue.toFixed(2);
    
    // Aktualisiere data-sort Attribut f√ºr korrekte Sortierung
    const rsiTd = rsiCell.closest('td');
    if (rsiTd) {
      rsiTd.setAttribute('data-sort', rsiValue);
      console.log("üìä data-sort Attribut aktualisiert:", rsiValue);
    }
    
    // RSI-Farbe basierend auf Wert
    rsiCell.className = 'badge rsi-cell';
    if (rsiValue >= 70) {
      rsiCell.classList.add('rsi-overbought'); // √úberkauft
    } else if (rsiValue <= 30) {
      rsiCell.classList.add('rsi-oversold'); // √úberverkauft
    } else {
      rsiCell.classList.add('rsi-neutral'); // Neutral
    }
    
    // Animation f√ºr RSI-Update
    rsiCell.style.transition = 'background-color 0.8s ease';
    rsiCell.style.backgroundColor = '#fff3cd'; // Gelber Hintergrund
    setTimeout(() => {
      rsiCell.style.backgroundColor = '';
    }, 800);
    
    console.log("‚úÖ RSI-Update abgeschlossen f√ºr:", data.symbol, "- Wert:", rsiValue.toFixed(2));
  } else {
    console.log("[!] RSI-Zelle nicht gefunden f√ºr Crypto ID:", data.cryptocurrency_id);
    console.log("üîç Zeilen-HTML:", row.innerHTML);
  }
 }
 
 // Funktion zum Behandeln von Indikator-Updates
 function handleIndicatorUpdate(data) {
   console.log("üìä Verarbeite Indikator-Update f√ºr", data.symbol, ":", data.indicator_type, "=", data.value);
   
   const row = document.querySelector(`[data-crypto-id='${data.cryptocurrency_id}']`);
   if (!row) {
     console.log("[!] Zeile nicht gefunden f√ºr Crypto ID:", data.cryptocurrency_id);
     return;
   }
   
   // Behandle verschiedene Indikator-Typen
   switch (data.indicator_type) {
          case 'rsi':
       handleRsiUpdate({
         cryptocurrency_id: data.cryptocurrency_id,
         symbol: data.symbol,
         rsi: data.value
       });
            break;
       
          case 'roc':
       handleRocUpdate({
         cryptocurrency_id: data.cryptocurrency_id,
         symbol: data.symbol,
         roc: data.value
       });
            break;
       
     case 'roc_derivative':
       handleRocDerivativeUpdate({
         cryptocurrency_id: data.cryptocurrency_id,
         symbol: data.symbol,
         roc_derivative: data.value
       });
            break;
       
     default:
       console.log(`üìä Unbekannter Indikator-Typ: ${data.indicator_type}`);
   }
 }

 // Funktion zum Behandeln von ROC-Updates
 function handleRocUpdate(data) {
   console.log("üìä Verarbeite ROC-Update f√ºr", data.symbol, ":", data.roc);
   
   const row = document.querySelector(`[data-crypto-id='${data.cryptocurrency_id}']`);
   if (!row) {
     console.log("[!] Zeile nicht gefunden f√ºr ROC Update, Crypto ID:", data.cryptocurrency_id);
     return;
   }
   
     const rocCell = row.querySelector('.roc-cell');
  if (rocCell) {
    const rocValue = parseFloat(data.roc);
    rocCell.textContent = `${rocValue.toFixed(2)}%`;
    
    // Aktualisiere data-sort Attribut f√ºr korrekte Sortierung
    const rocTd = rocCell.closest('td');
    if (rocTd) {
      rocTd.setAttribute('data-sort', rocValue);
      console.log("üìä ROC data-sort Attribut aktualisiert:", rocValue);
    }
    
    // Aktualisiere CSS-Klassen basierend auf ROC-Wert
    rocCell.className = 'badge roc-cell';
    if (rocValue >= 5) {
      rocCell.classList.add('bg-success');
    } else if (rocValue <= -5) {
      rocCell.classList.add('bg-danger');
        } else {
      rocCell.classList.add('bg-secondary');
        }
    
    console.log(`‚úÖ ROC aktualisiert f√ºr ${data.symbol}: ${rocValue.toFixed(2)}%`);
      } else {
    console.log("[!] ROC-Zelle nicht gefunden f√ºr", data.symbol);
  }
 }

 // Funktion zum Behandeln von ROC Derivative Updates
 function handleRocDerivativeUpdate(data) {
   console.log("üìä Verarbeite ROC' Update f√ºr", data.symbol, ":", data.roc_derivative);
   
   const row = document.querySelector(`[data-crypto-id='${data.cryptocurrency_id}']`);
   if (!row) {
     console.log("[!] Zeile nicht gefunden f√ºr ROC' Update, Crypto ID:", data.cryptocurrency_id);
    return;
  }
  
     const rocDerivativeCell = row.querySelector('.roc-derivative-cell');
  if (rocDerivativeCell) {
    const rocDerivativeValue = parseFloat(data.roc_derivative);
    rocDerivativeCell.textContent = `${rocDerivativeValue.toFixed(2)}%`;
    
    // Aktualisiere data-sort Attribut f√ºr korrekte Sortierung
    const rocDerivativeTd = rocDerivativeCell.closest('td');
    if (rocDerivativeTd) {
      rocDerivativeTd.setAttribute('data-sort', rocDerivativeValue);
      console.log("üìä ROC' data-sort Attribut aktualisiert:", rocDerivativeValue);
    }
    
    // Aktualisiere CSS-Klassen basierend auf ROC' Wert
    rocDerivativeCell.className = 'badge roc-derivative-cell';
    if (rocDerivativeValue >= 2) {
      rocDerivativeCell.classList.add('bg-success');
    } else if (rocDerivativeValue <= -2) {
      rocDerivativeCell.classList.add('bg-danger');
    } else {
      rocDerivativeCell.classList.add('bg-secondary');
    }
    
    console.log(`‚úÖ ROC' aktualisiert f√ºr ${data.symbol}: ${rocDerivativeValue.toFixed(2)}%`);
    } else {
    console.log("[!] ROC'-Zelle nicht gefunden f√ºr", data.symbol);
  }
 }

  // Funktion zum Behandeln von Z√§hler-Updates
  function handleCounterUpdate(data) {
    console.log("üìä Verarbeite Z√§hler-Update:", data);
    
    const messageCounter = document.getElementById('message-counter');
    const klineCounter = document.getElementById('kline-counter');
    const priceUpdateCounter = document.getElementById('price-update-counter');
    const dataRateCounter = document.getElementById('data-rate-counter');

    if (messageCounter) {
      messageCounter.textContent = data.message_counter || 0;
      console.log("üí¨ Nachrichten-Z√§hler aktualisiert:", data.message_counter);
    }
    if (klineCounter) {
      klineCounter.textContent = data.kline_counter || 0;
      console.log("üìà Klines-Z√§hler aktualisiert:", data.kline_counter);
    }
    if (priceUpdateCounter) {
      priceUpdateCounter.textContent = data.price_update_counter || 0;
      console.log("üí∞ Preis-Updates-Z√§hler aktualisiert:", data.price_update_counter);
    }
    if (rsiCalculationCounter) {
      rsiCalculationCounter.textContent = data.rsi_calculation_counter || 0;
      console.log("üìä RSI-Berechnungen-Z√§hler aktualisiert:", data.rsi_calculation_counter);
    }
    if (dataRateCounter) {
      dataRateCounter.textContent = data.data_rate || 0;
      console.log("üíæ Datenrate aktualisiert:", data.data_rate);
    }
}

// Timeframe und RSI-Konfiguration Funktionalit√§t (nur Frontend)
  const timeframeSelector = document.getElementById('timeframe-selector');
  const rsiPeriodInput = document.getElementById('rsi-period-input');
  
  if (timeframeSelector && rsiPeriodInput) {
    // Lade gespeicherte Werte aus localStorage
    const savedTimeframe = localStorage.getItem('selected-timeframe');
    const savedRsiPeriod = localStorage.getItem('selected-rsi-period');
    
                    if (savedTimeframe) {
                  timeframeSelector.value = savedTimeframe;
                  console.log('üïê Gespeicherter Timeframe geladen:', savedTimeframe);
                } else {
                  // Standard: 1 Minute
                  timeframeSelector.value = '1m';
                  localStorage.setItem('selected-timeframe', '1m');
                  console.log('üïê Standard-Timeframe gesetzt: 1m');
                }
                
                if (savedRsiPeriod) {
                  rsiPeriodInput.value = savedRsiPeriod;
                  console.log('üìä Gespeicherte RSI-Periode geladen:', savedRsiPeriod);
                } else {
                  // Standard: 14
                  rsiPeriodInput.value = '14';
                  localStorage.setItem('selected-rsi-period', '14');
                  console.log('üìä Standard-RSI-Periode gesetzt: 14');
                }
                
                // Aktualisiere Backend mit aktuellen Einstellungen beim Laden der Seite
                updateBackendSettings(timeframeSelector.value, rsiPeriodInput.value);
    
                    // Event Listener f√ºr Timeframe-√Ñnderungen
                timeframeSelector.addEventListener('change', function() {
                  const selectedTimeframe = this.value;
                  localStorage.setItem('selected-timeframe', selectedTimeframe);
                  
                  console.log('üïê Timeframe ge√§ndert zu:', selectedTimeframe);
                  
                  // Speichere Timeframe im Rails-Cache f√ºr WebSocket-Service
                  updateBackendSettings(selectedTimeframe, rsiPeriodInput.value);
                  
                  // Zeige Benachrichtigung
                  showTimeframeNotification(selectedTimeframe, 'info');
                  
                  // Starte RSI-Berechnung mit neuem Timeframe
                  startRsiCalculation(selectedTimeframe, rsiPeriodInput.value);
                  
                  // Aktualisiere Mini-Candlesticks mit neuem Timeframe
                  refreshMiniCandlesticks(selectedTimeframe);
                });
    
                    // Event Listener f√ºr RSI-Perioden-√Ñnderungen
                rsiPeriodInput.addEventListener('change', function() {
                  const selectedRsiPeriod = this.value;
                  localStorage.setItem('selected-rsi-period', selectedRsiPeriod);
                  
                  console.log('üìä RSI-Periode ge√§ndert zu:', selectedRsiPeriod);
                  
                  // Speichere RSI-Periode im Rails-Cache f√ºr WebSocket-Service
                  updateBackendSettings(timeframeSelector.value, selectedRsiPeriod);
                  
                  // Zeige Benachrichtigung
                  showRsiPeriodNotification(selectedRsiPeriod, 'info');
                  
                  // Starte RSI-Berechnung mit neuer Periode
                  startRsiCalculation(timeframeSelector.value, selectedRsiPeriod);
                });
    
                    // Funktion zum Aktualisieren der Backend-Einstellungen
                function updateBackendSettings(timeframe, period) {
                  fetch('/cryptocurrencies/update_rsi_settings', {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                      'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''
                    },
                    body: JSON.stringify({ 
                      timeframe: timeframe, 
                      period: parseInt(period) 
                    })
                  })
                  .then(response => response.json())
                  .then(data => {
                    if (data.success) {
                      console.log('‚úÖ Backend-Einstellungen aktualisiert:', data.message);
                    } else {
                      console.error('‚ùå Fehler beim Aktualisieren der Backend-Einstellungen:', data.error);
                    }
                  })
                  .catch(error => {
                    console.error('‚ùå Netzwerkfehler beim Aktualisieren der Backend-Einstellungen:', error);
                  });
                }
                
                // Funktion zum Starten der RSI-Berechnung
                function startRsiCalculation(timeframe, period) {
      console.log('üöÄ Starte RSI-Berechnung:', { timeframe, period });
      
      fetch('/cryptocurrencies/calculate_rsi', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''
        },
        body: JSON.stringify({ 
          timeframe: timeframe, 
          period: parseInt(period) 
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          console.log('‚úÖ RSI-Berechnung gestartet:', data.message);
          showCalculationNotification('RSI-Berechnung gestartet', 'success');
        } else {
          console.error('‚ùå Fehler bei RSI-Berechnung:', data.error);
          showCalculationNotification('Fehler bei RSI-Berechnung', 'error');
        }
      })
      .catch(error => {
        console.error('‚ùå Netzwerkfehler bei RSI-Berechnung:', error);
        showCalculationNotification('Netzwerkfehler bei RSI-Berechnung', 'error');
      });
    }
    
    // Funktion zum Anzeigen einer Berechnungs-Benachrichtigung
    function showCalculationNotification(message, type = 'info') {
      // Entferne bestehende Benachrichtigung
      const existingNotification = document.querySelector('.calculation-notification');
      if (existingNotification) {
        existingNotification.remove();
      }
      
      // Bestimme CSS-Klasse basierend auf Typ
      let alertClass = 'alert-info';
      let icon = 'bi-calculator';
      
      if (type === 'success') {
        alertClass = 'alert-success';
        icon = 'bi-check-circle';
      } else if (type === 'error') {
        alertClass = 'alert-danger';
        icon = 'bi-exclamation-triangle';
      }
      
      // Erstelle neue Benachrichtigung
      const notification = document.createElement('div');
      notification.className = `calculation-notification alert ${alertClass} alert-dismissible fade show position-fixed`;
      notification.style.cssText = 'top: 60px; right: 20px; z-index: 1050; max-width: 300px;';
      
      notification.innerHTML = `
        <i class="bi ${icon}"></i>
        <strong>${message}</strong>
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      document.body.appendChild(notification);
      
      // Automatisch nach 5 Sekunden ausblenden
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 5000);
    }
    
    // Funktion zum Anzeigen einer Benachrichtigung
    function showTimeframeNotification(timeframe, type = 'info') {
      // Entferne bestehende Benachrichtigung
      const existingNotification = document.querySelector('.timeframe-notification');
      if (existingNotification) {
        existingNotification.remove();
      }
      
      // Bestimme CSS-Klasse basierend auf Typ
      let alertClass = 'alert-info';
      let icon = 'bi-clock';
      let message = 'Timeframe ge√§ndert';
      
      if (type === 'success') {
        alertClass = 'alert-success';
        icon = 'bi-check-circle';
        message = 'Timeframe erfolgreich aktualisiert';
      } else if (type === 'error') {
        alertClass = 'alert-danger';
        icon = 'bi-exclamation-triangle';
        message = 'Fehler beim Aktualisieren des Timeframes';
      }
      
      // Erstelle neue Benachrichtigung
      const notification = document.createElement('div');
      notification.className = `timeframe-notification alert ${alertClass} alert-dismissible fade show position-fixed`;
      notification.style.cssText = 'top: 20px; right: 20px; z-index: 1050; max-width: 300px;';
      
      const timeframeLabels = {
        '1m': '1 Minute',
        '5m': '5 Minuten', 
        '15m': '15 Minuten',
        '1h': '1 Stunde',
        '4h': '4 Stunden',
        '1d': '1 Tag'
      };
      
      notification.innerHTML = `
        <i class="bi ${icon}"></i>
        <strong>${message}:</strong> ${timeframeLabels[timeframe]}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      document.body.appendChild(notification);
      
      // Automatisch nach 3 Sekunden ausblenden
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 3000);
    }
    
    // Funktion zum Anzeigen einer RSI-Perioden-Benachrichtigung
    function showRsiPeriodNotification(period, type = 'info') {
      // Entferne bestehende Benachrichtigung
      const existingNotification = document.querySelector('.rsi-period-notification');
      if (existingNotification) {
        existingNotification.remove();
      }
      
      // Bestimme CSS-Klasse basierend auf Typ
      let alertClass = 'alert-info';
      let icon = 'bi-graph-up';
      let message = 'RSI-Periode ge√§ndert';
      
      if (type === 'success') {
        alertClass = 'alert-success';
        icon = 'bi-check-circle';
        message = 'RSI-Periode erfolgreich aktualisiert';
      } else if (type === 'error') {
        alertClass = 'alert-danger';
        icon = 'bi-exclamation-triangle';
        message = 'Fehler beim Aktualisieren der RSI-Periode';
      }
      
      // Erstelle neue Benachrichtigung
      const notification = document.createElement('div');
      notification.className = `rsi-period-notification alert ${alertClass} alert-dismissible fade show position-fixed`;
      notification.style.cssText = 'top: 20px; right: 20px; z-index: 1050; max-width: 300px;';
      
      notification.innerHTML = `
        <i class="bi ${icon}"></i>
        <strong>${message}:</strong> ${period} Kerzen
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      document.body.appendChild(notification);
      
      // Automatisch nach 3 Sekunden ausblenden
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 3000);
    }
    
    // Funktion zum Behandeln von Z√§hler-Updates
    function handleCounterUpdate(data) {
      console.log("üìä Verarbeite Z√§hler-Update:", data);
      
      const messageCounter = document.getElementById('message-counter');
      const klineCounter = document.getElementById('kline-counter');
      const priceUpdateCounter = document.getElementById('price-update-counter');
      const rsiCalculationCounter = document.getElementById('rsi-calculation-counter');
      const dataRateCounter = document.getElementById('data-rate-counter');
      
      console.log("üîç Gefundene Z√§hler-Elemente:", {
        messageCounter: messageCounter,
        klineCounter: klineCounter,
        priceUpdateCounter: priceUpdateCounter,
        dataRateCounter: dataRateCounter
      });
      
      if (messageCounter) {
        messageCounter.textContent = data.message_counter || 0;
        console.log("üí¨ Nachrichten-Z√§hler aktualisiert:", data.message_counter);
      } else {
        console.log("[!] message-counter Element nicht gefunden");
      }
      if (klineCounter) {
        klineCounter.textContent = data.kline_counter || 0;
        console.log("üìà Klines-Z√§hler aktualisiert:", data.kline_counter);
      } else {
        console.log("[!] kline-counter Element nicht gefunden");
      }
      if (priceUpdateCounter) {
        priceUpdateCounter.textContent = data.price_update_counter || 0;
        console.log("üí∞ Preis-Updates-Z√§hler aktualisiert:", data.price_update_counter);
      } else {
        console.log("[!] price-update-counter Element nicht gefunden");
      }
              if (dataRateCounter) {
          dataRateCounter.textContent = data.data_rate || 0;
          console.log("üíæ Datenrate aktualisiert:", data.data_rate);
        } else {
          console.log("[!] data-rate-counter Element nicht gefunden");
        }
    }
    
    // Starte automatische Z√§hler-Updates
    // ENTFERNT: Keine simulierten Z√§hler mehr - wir verwenden echte Daten vom WebSocket-Service...
    console.log("üéØ Warte auf echte Z√§hler-Updates vom WebSocket-Service...");
  }
});
</script>

<div class="container mt-4">
  <div class="row">
    <div class="col-12">
      <div class="d-flex justify-content-between align-items-center mb-4">
        <h1>Kryptow√§hrungen Scanner</h1>
        <!-- Button Einstellungen entfernt -->
      </div>



      <!-- Timeframe und RSI-Konfiguration -->
      <div class="mb-3">
        <div class="d-flex justify-content-between align-items-center">
          <div class="d-flex align-items-center gap-3">
            <div class="d-flex align-items-center">
              <label for="timeframe-selector" class="form-label me-2 mb-0">
                <i class="bi bi-clock"></i> Timeframe:
              </label>
              <select id="timeframe-selector" class="form-select form-select-sm" style="width: auto;">
                <option value="1m">1 Minute</option>
                <option value="5m">5 Minuten</option>
                <option value="15m">15 Minuten</option>
                <option value="1h">1 Stunde</option>
                <option value="4h">4 Stunden</option>
                <option value="1d">1 Tag</option>
              </select>
            </div>
            
            <div class="d-flex align-items-center">
              <label for="rsi-period-input" class="form-label me-2 mb-0">
                <i class="bi bi-graph-up"></i> RSI-Periode:
              </label>
              <input type="number" id="rsi-period-input" class="form-control form-control-sm" 
                     value="14" min="1" max="50" style="width: 80px;"
                     title="Anzahl der Kerzen f√ºr RSI-Berechnung (Standard: 14)">
            </div>
          </div>
          
          <!-- Live-Daten Status -->
          <div>
            <small class="text-success">
              <i class="bi bi-check-circle"></i> Live-Daten von Binance API (1m Updates)
            </small>
          </div>
        </div>
      </div>

      <!-- Durchschnittswerte -->
        <% if @average_rsi || @average_roc || @average_roc_derivative %>
          <div class="mb-2">
            <div class="d-flex gap-3 justify-content-end">
              <% if @average_rsi %>
                <% rsi_trend_icon = case @rsi_trend
                                     when 'up' then 'bi-arrow-up-right text-success'
                                     when 'down' then 'bi-arrow-down-right text-danger'
                                     else 'bi-arrow-right text-muted'
                                   end %>
                <small class="text-info averages-tooltip" 
                       data-bs-toggle="tooltip" 
                       data-bs-html="true"
                       data-bs-placement="bottom"
                       data-bs-custom-class="chart-tooltip"
                       data-chart-type="rsi"
                       title="<div class='text-center'>
                         <strong>RSI Durchschnitt</strong><br>
                         <span class='h5 text-info'><%= @average_rsi %></span><br>
                         <small class='text-muted'>Relative Strength Index</small><br>
                         <div class='mt-2'>
                           <i class='bi <%= rsi_trend_icon %>'></i>
                           <small class='text-muted ms-1'>Trend: <%= @rsi_trend == 'up' ? 'Anstieg' : (@rsi_trend == 'down' ? 'R√ºckgang' : 'Gleichbleibend') %></small>
                         </div>
                         <div class='mt-2'>
                           <canvas id='rsi-chart' width='200' height='60' style='max-width: 200px; max-height: 60px; border: 1px solid rgba(255,255,255,0.2);'></canvas>
                         </div>
                       </div>">
                  <%= link_to averages_chart_cryptocurrencies_path, target: '_blank', class: 'text-decoration-none text-info' do %>
                    <i class="bi bi-speedometer2"></i> RSI √ò: <strong><%= @average_rsi %></strong>
                    <i class="bi <%= rsi_trend_icon %> ms-1"></i>
                  <% end %>
                </small>
              <% end %>
            </div>
          </div>
        <% end %>
    </div>
  </div>
</div>

<% if @cryptocurrencies.any? %>
  <!-- Responsive Table View (alle Bildschirmgr√∂√üen) -->
  <div class="table-responsive">
    <table id="crypto-table" class="table table-hover">
      <thead class="table-dark">
        <tr>
          <th class="d-none d-md-table-cell">Rang</th>
          <th class="d-none d-lg-table-cell">Name</th>
          <th>Symbol</th>
          <th>Preis</th>
          <th class="d-none d-lg-table-cell">24h √Ñnderung</th>
          <th class="d-none d-xl-table-cell">Market Cap</th>
          <th class="d-none d-xl-table-cell">Volumen 24h (USD)</th>
          <th>
            RSI
            <% if @average_rsi %>
              <br><small class="text-info d-none d-md-inline">√ò <%= @average_rsi %></small>
            <% end %>
          </th>
          <th class="d-none d-lg-table-cell">
            ROC
            <br><small class="text-muted d-none d-md-inline">Rate of Change</small>
          </th>
          <th class="d-none d-lg-table-cell">
            ROC'
            <br><small class="text-muted d-none d-md-inline">ROC Derivative</small>
          </th>
          <th>Chart</th>
          <th class="d-none d-lg-table-cell">
            1h Kerze
            <br><small class="text-muted d-none d-md-inline">Aktuelle Stunde</small>
          </th>
        </tr>
      </thead>
      <tbody>
        <% @cryptocurrencies.each_with_index do |crypto, crypto_index| %>
          <tr data-crypto-id="<%= crypto.id %>">
            <td class="d-none d-md-table-cell">
              <span class="badge bg-secondary">#<%= crypto.market_cap_rank %></span>
            </td>
            <td class="d-none d-lg-table-cell">
              <strong><%= crypto.display_name %></strong>
            </td>
            <td>
              <%= link_to "https://www.binance.com/en/trade/#{crypto.base_symbol}_USDC?_from=markets&type=spot", 
                  target: '_blank',
                  class: 'text-decoration-none',
                  title: "#{crypto.display_name} auf Binance handeln" do %>
                <span class="badge bg-light text-dark"><%= crypto.base_symbol %></span>
              <% end %>
              <span class="d-md-none">
                <br><small class="text-muted">#<%= crypto.market_cap_rank %></small>
              </span>
            </td>
            <td data-sort="<%= @latest_prices[crypto.id] || 0 %>">
              <strong class="price-cell">
                <% price = @latest_prices[crypto.id] %>
                <% if price.present? %>
                  <%= link_to (price >= 1 ? "$#{price.round(2)}" : "$#{price.round(6)}"), chart_cryptocurrency_path(crypto), target: '_blank', class: 'text-decoration-none text-primary chart-link', title: 'Chart anzeigen' %>
                <% else %>
                  <span class="text-muted">N/A</span>
                <% end %>
              </strong>
            </td>
            <td class="d-none d-lg-table-cell">
              <% if crypto.price_change_percentage_24h %>
                <%# Bestimme die Farbe basierend auf Vollst√§ndigkeit der 24h-Daten %>
                <% color_class = if crypto.price_change_24h_complete?
                                   crypto.price_change_percentage_24h >= 0 ? 'text-success' : 'text-danger'
                                 else
                                   'text-danger' # Unvollst√§ndige Daten immer rot
                                 end %>
                <span class="<%= color_class %>">
                  <% if crypto.price_change_percentage_24h >= 0 %>
                    <i class="bi bi-arrow-up"></i>
                  <% else %>
                    <i class="bi bi-arrow-down"></i>
                  <% end %>
                  <%= crypto.price_change_percentage_24h_formatted %>
                </span>
              <% else %>
                <span class="text-muted">0.00%</span>
              <% end %>
            </td>
            <td class="d-none d-xl-table-cell"><%= crypto.formatted_market_cap %></td>
            <td class="d-none d-xl-table-cell">
              <%= crypto.formatted_volume_24h %>
            </td>
            <td data-sort="<%= crypto.current_rsi(@current_timeframe) || -1 %>">
              <% if crypto.current_rsi(@current_timeframe) %>
                <% rsi_class = if crypto.current_rsi(@current_timeframe) <= 30
                                 "rsi-oversold"
                               elsif crypto.current_rsi(@current_timeframe) >= 70
                                 "rsi-overbought"
                               else
                                 "rsi-neutral"
                               end %>
                <%= link_to chart_cryptocurrency_path(crypto), 
                    target: '_blank',
                    class: 'text-decoration-none',
                    title: "RSI Chart anzeigen" do %>
                  <span class="badge <%= rsi_class %> chart-link rsi-cell">
                    <%= crypto.current_rsi(@current_timeframe) %>
                  </span>
                <% end %>
              <% else %>
                <span class="badge bg-secondary rsi-cell">N/A</span>
              <% end %>
            </td>
            
            <td class="d-none d-lg-table-cell" data-sort="<%= crypto.current_roc(@current_timeframe) || -999 %>">
              <% if crypto.current_roc(@current_timeframe) %>
                <% roc_class = if crypto.current_roc(@current_timeframe) >= 5
                                 "bg-success"
                               elsif crypto.current_roc(@current_timeframe) <= -5
                                 "bg-danger"
                               else
                                 "bg-secondary"
                               end %>
                <span class="badge <%= roc_class %> roc-cell">
                  <%= crypto.current_roc(@current_timeframe).round(2) %>%
                </span>
              <% else %>
                <span class="badge bg-secondary roc-cell">N/A</span>
              <% end %>
            </td>
            
            <td class="d-none d-lg-table-cell" data-sort="<%= crypto.current_roc_derivative(@current_timeframe) || -999 %>">
              <% if crypto.current_roc_derivative(@current_timeframe) %>
                <% roc_derivative_class = if crypto.current_roc_derivative(@current_timeframe) >= 2
                                            "bg-success"
                                          elsif crypto.current_roc_derivative(@current_timeframe) <= -2
                                            "bg-danger"
                                          else
                                            "bg-secondary"
                                          end %>
                <span class="badge <%= roc_derivative_class %> roc-derivative-cell">
                  <%= crypto.current_roc_derivative(@current_timeframe).round(2) %>%
                </span>
              <% else %>
                <span class="badge bg-secondary roc-derivative-cell">N/A</span>
              <% end %>
            </td>
                         <td>
               <div class="mini-candlestick-container" data-crypto-id="<%= crypto.id %>" data-symbol="<%= crypto.symbol %>">
                 <canvas class="mini-candlestick" width="80" height="30" data-crypto-id="<%= crypto.id %>"></canvas>
                 <div class="candlestick-info d-none">
                   <small class="text-muted">O: <span class="open-price">-</span></small><br>
                   <small class="text-muted">H: <span class="high-price">-</span></small><br>
                   <small class="text-muted">L: <span class="low-price">-</span></small><br>
                   <small class="text-muted">C: <span class="close-price">-</span></small>
                 </div>
               </div>
             </td>
             <td class="d-none d-lg-table-cell">
               <div class="current-1h-candle-container" data-crypto-id="<%= crypto.id %>" data-symbol="<%= crypto.symbol %>">
                 <canvas class="current-1h-candle" width="60" height="40" data-crypto-id="<%= crypto.id %>"></canvas>
                 <div class="candlestick-info d-none">
                   <small class="text-muted">O: <span class="open-price">-</span></small><br>
                   <small class="text-muted">H: <span class="high-price">-</span></small><br>
                   <small class="text-muted">L: <span class="low-price">-</span></small><br>
                   <small class="text-muted">C: <span class="close-price">-</span></small>
                 </div>
               </div>
             </td>
          </tr>
        <% end %>
      </tbody>
    </table>
  </div>

  <!-- WebSocket Z√§hler unterhalb der Tabelle -->
  <div class="mt-4">
    <div class="row">
      <div class="col-md-3">
        <div class="card border-primary">
          <div class="card-body text-center py-2">
            <h6 class="card-title text-primary mb-1">
              <i class="bi bi-envelope"></i> Nachrichten
            </h6>
            <div class="h4 mb-0 text-primary" id="message-counter">0</div>
            <small class="text-muted">Empfangen</small>
          </div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card border-success">
          <div class="card-body text-center py-2">
            <h6 class="card-title text-success mb-1">
              <i class="bi bi-graph-up"></i> Klines
            </h6>
            <div class="h4 mb-0 text-success" id="kline-counter">0</div>
            <small class="text-muted">Verarbeitet</small>
          </div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card border-warning">
          <div class="card-body text-center py-2">
            <h6 class="card-title text-warning mb-1">
              <i class="bi bi-currency-dollar"></i> Preis-Updates
            </h6>
            <div class="h4 mb-0 text-warning" id="price-update-counter">0</div>
            <small class="text-muted">Gesendet</small>
          </div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card border-info">
          <div class="card-body text-center py-2">
            <h6 class="card-title text-info mb-1">
              <i class="bi bi-speedometer"></i> Datenrate
            </h6>
            <div class="h4 mb-0 text-info" id="data-rate-counter">0</div>
            <small class="text-muted">Nachrichten/min</small>
          </div>
        </div>
      </div>
    </div>
  </div>

<% else %>
  <!-- Empty State -->
  <div class="text-center py-5">
    <i class="bi bi-exclamation-triangle display-1 text-warning"></i>
    <h3 class="mt-3">Keine Daten verf√ºgbar</h3>
    <p class="text-muted">
      Es konnten keine Kryptow√§hrungsdaten geladen werden. 
      Bitte √ºberpr√ºfen Sie Ihre Internetverbindung und versuchen Sie es erneut.
    </p>
  </div>
<% end %> 

<style>
/* Mini-Candlestick Styling */
.mini-candlestick-container {
  position: relative;
  display: inline-block;
}

.mini-candlestick {
  border: 1px solid #dee2e6;
  border-radius: 4px;
  background-color: #f8f9fa;
  cursor: pointer;
  transition: all 0.2s ease;
}

.mini-candlestick:hover {
  border-color: #007bff;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

/* Aktuelle 1h Kerze Styling */
.current-1h-candle-container {
  position: relative;
  display: inline-block;
}

.current-1h-candle {
  border: 1px solid #dee2e6;
  border-radius: 4px;
  background-color: #f8f9fa;
  cursor: pointer;
  transition: all 0.2s ease;
}

.current-1h-candle:hover {
  border-color: #28a745;
  box-shadow: 0 0 0 0.2rem rgba(40, 167, 69, 0.25);
}

.current-1h-candle.incomplete {
  border-color: #ffc107;
  background-color: #fff3cd;
}

.current-1h-candle.complete {
  border-color: #28a745;
  background-color: #d4edda;
}

.current-1h-candle.old {
  border-color: #6c757d;
  background-color: #f8f9fa;
  opacity: 0.7;
}

.candlestick-info {
  position: absolute;
  top: -80px;
  left: 50%;
  transform: translateX(-50%);
  background-color: #343a40;
  color: white;
  padding: 8px;
  border-radius: 4px;
  font-size: 11px;
  z-index: 1000;
  white-space: nowrap;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.candlestick-info::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 4px solid transparent;
  border-top-color: #343a40;
}

/* Responsive Anpassungen */
@media (max-width: 768px) {
  .mini-candlestick {
    width: 60px !important;
    height: 25px !important;
  }
  
  .current-1h-candle {
    width: 50px !important;
    height: 30px !important;
  }
  
  .candlestick-info {
    font-size: 10px;
    padding: 6px;
  }
}
</style>

<script>
            // Mini-Candlestick Charts f√ºr die Tabelle
            document.addEventListener('DOMContentLoaded', function() {
              const candlestickCanvases = document.querySelectorAll('.mini-candlestick');

              candlestickCanvases.forEach(canvas => {
                const cryptoId = canvas.dataset.cryptoId;
                const container = canvas.closest('.mini-candlestick-container');
                const infoDiv = container.querySelector('.candlestick-info');

                // Lade echte Candlestick-Daten vom Server
                const candlestickData = loadRealCandlestickData(cryptoId);

                // Zeichne Mini-Candlesticks
                drawMiniCandlesticks(canvas, candlestickData);

                // Tooltip-Funktionalit√§t f√ºr Mini-Candlesticks (letzte vollst√§ndige Kerze)
                canvas.addEventListener('mouseenter', function() {
                  infoDiv.classList.remove('d-none');
                  const lastCompleteCandle = findLastCompleteCandle(cryptoId);
                  if (lastCompleteCandle) {
                    updateMiniCandlestickInfo(infoDiv, lastCompleteCandle);
                  }
                });

                canvas.addEventListener('mouseleave', function() {
                  infoDiv.classList.add('d-none');
                });
              });
              
              // Aktuelle 1h Kerzen f√ºr die Tabelle
              const current1hCandleCanvases = document.querySelectorAll('.current-1h-candle');
              console.log(`üïØÔ∏è Gefundene 1h Kerzen-Canvases: ${current1hCandleCanvases.length}`);

              current1hCandleCanvases.forEach(canvas => {
                const cryptoId = canvas.dataset.cryptoId;
                const container = canvas.closest('.current-1h-candle-container');
                const infoDiv = container.querySelector('.candlestick-info');

                console.log(`üïØÔ∏è Initialisiere 1h Kerze f√ºr Crypto ID: ${cryptoId}`);

                // Lade aktuelle 1h Kerzen-Daten vom Server
                let current1hData = loadCurrent1hCandleData(cryptoId);
                console.log(`üïØÔ∏è Geladene 1h Daten f√ºr ${cryptoId}:`, current1hData);

                // Falls keine Daten im Cache, generiere aus Mini-Candlestick-Daten
                if (!current1hData) {
                  console.log(`üïØÔ∏è Keine 1h Daten im Cache f√ºr ${cryptoId}, generiere aus Mini-Candlestick-Daten...`);
                  const generatedData = generateCurrent1hCandleData(cryptoId);
                  if (generatedData) {
                    current1hCandleCache[cryptoId] = generatedData;
                    drawCurrent1hCandle(canvas, generatedData);
                    console.log(`‚úÖ 1h Kerze aus generierten Daten gezeichnet f√ºr ${cryptoId}`);
                  } else {
                    console.log(`‚ö†Ô∏è Keine Daten f√ºr 1h Kerze verf√ºgbar f√ºr ${cryptoId}`);
                    drawCurrent1hCandle(canvas, null);
                  }
                } else {
                  // Zeichne aktuelle 1h Kerze
                  drawCurrent1hCandle(canvas, current1hData);
                }

                // Tooltip-Funktionalit√§t f√ºr 1h Kerzen
                canvas.addEventListener('mouseenter', function() {
                  infoDiv.classList.remove('d-none');
                  if (current1hData) {
                    update1hCandleInfo(infoDiv, current1hData);
                  }
                });

                canvas.addEventListener('mouseleave', function() {
                  infoDiv.classList.add('d-none');
                });
              });
            });

            // Lade echte Candlestick-Daten vom Server
            let candlestickDataCache = <%= raw @mini_candlestick_data.to_json %>;
            console.log('üïØÔ∏è Initialer Candlestick-Daten-Cache:', candlestickDataCache);
            console.log('üïØÔ∏è Cache-Keys:', Object.keys(candlestickDataCache));
            console.log('üïØÔ∏è Cache-Gr√∂√üe:', Object.keys(candlestickDataCache).length);
            
            // Lade aktuelle 1h Kerzen-Daten vom Server
            let current1hCandleCache = <%= raw @current_1h_candle_data.to_json %>;
            console.log('üïØÔ∏è Initialer 1h Kerzen-Cache:', current1hCandleCache);
            console.log('üïØÔ∏è 1h Cache-Keys:', Object.keys(current1hCandleCache));
            console.log('üïØÔ∏è 1h Cache-Gr√∂√üe:', Object.keys(current1hCandleCache).length);
            
            function loadRealCandlestickData(cryptoId) {
              // Verwende die gecachten Daten
              const data = candlestickDataCache[cryptoId] || [];
              console.log(`üïØÔ∏è Lade Daten f√ºr Crypto ID ${cryptoId}:`, data);
              return data;
            }
            
            // Update die gecachten Daten
            function updateCandlestickDataCache(cryptoId, newData) {
              candlestickDataCache[cryptoId] = newData;
            }
            
            // Lade aktuelle 1h Kerzen-Daten
            function loadCurrent1hCandleData(cryptoId) {
              const data = current1hCandleCache[cryptoId] || null;
              console.log(`üïØÔ∏è Lade 1h Kerzen-Daten f√ºr Crypto ID ${cryptoId}:`, data);
              
              // Debug: Zeige alle verf√ºgbaren Cache-Daten
              if (!data) {
                console.log(`‚ö†Ô∏è Keine 1h Daten f√ºr ${cryptoId} im Cache`);
                console.log(`üîç Verf√ºgbare Cache-Keys:`, Object.keys(current1hCandleCache));
                console.log(`üîç Cache-Inhalt:`, current1hCandleCache);
                
                // Tempor√§re L√∂sung: Versuche 1h Daten aus Mini-Candlestick-Daten zu generieren
                const miniData = candlestickDataCache[cryptoId] || [];
                if (miniData.length > 0) {
                  console.log(`üïØÔ∏è Verwende Mini-Candlestick-Daten als Fallback f√ºr 1h Kerze`);
                  const lastCandle = miniData[miniData.length - 1];
                  return {
                    open: lastCandle.open,
                    high: lastCandle.high,
                    low: lastCandle.low,
                    close: lastCandle.close,
                    timestamp: lastCandle.timestamp,
                    isGreen: lastCandle.isGreen,
                    isComplete: false,
                    isCurrentHour: false
                  };
                }
              }
              
              return data;
            }
            
            // Update die gecachten 1h Kerzen-Daten
            function updateCurrent1hCandleCache(cryptoId, newData) {
              current1hCandleCache[cryptoId] = newData;
            }
            
            // Generiere 1h Kerzen-Daten aus Mini-Candlestick-Daten
            function generateCurrent1hCandleData(cryptoId) {
              console.log(`üïØÔ∏è Generiere 1h Kerzen-Daten f√ºr Crypto ID: ${cryptoId}`);
              
              const miniData = candlestickDataCache[cryptoId] || [];
              if (miniData.length === 0) {
                console.log(`‚ö†Ô∏è Keine Mini-Candlestick-Daten f√ºr ${cryptoId} verf√ºgbar`);
                return null;
              }
              
              // Verwende die letzte Kerze als 1h Kerze
              const lastCandle = miniData[miniData.length - 1];
              const currentTime = new Date();
              const candleTime = new Date(lastCandle.timestamp);
              const isCurrentHour = currentTime.getHours() === candleTime.getHours() && 
                                   currentTime.getDate() === candleTime.getDate();
              
              const generatedData = {
                open: lastCandle.open,
                high: lastCandle.high,
                low: lastCandle.low,
                close: lastCandle.close,
                timestamp: lastCandle.timestamp,
                isGreen: lastCandle.isGreen,
                isComplete: !isCurrentHour,
                isCurrentHour: isCurrentHour
              };
              
              console.log(`‚úÖ 1h Kerzen-Daten generiert f√ºr ${cryptoId}:`, generatedData);
              return generatedData;
            }
            
            // Finde die letzte vollst√§ndige Kerze aus Mini-Candlestick-Daten
            function findLastCompleteCandle(cryptoId) {
              console.log(`üïØÔ∏è Suche letzte vollst√§ndige Kerze f√ºr Crypto ID: ${cryptoId}`);
              
              const miniData = candlestickDataCache[cryptoId] || [];
              if (miniData.length === 0) {
                console.log(`‚ö†Ô∏è Keine Mini-Candlestick-Daten f√ºr ${cryptoId} verf√ºgbar`);
                return null;
              }
              
              const currentTime = new Date();
              
              // Suche die letzte vollst√§ndige Kerze (nicht aus der aktuellen Stunde)
              for (let i = miniData.length - 1; i >= 0; i--) {
                const candle = miniData[i];
                const candleTime = new Date(candle.timestamp);
                
                // Pr√ºfe ob Kerze nicht aus der aktuellen Stunde ist
                if (currentTime.getHours() !== candleTime.getHours() || 
                    currentTime.getDate() !== candleTime.getDate()) {
                  console.log(`‚úÖ Letzte vollst√§ndige Kerze gefunden f√ºr ${cryptoId}:`, candle);
                  return candle;
                }
              }
              
              // Falls keine vollst√§ndige Kerze gefunden, verwende die letzte
              const lastCandle = miniData[miniData.length - 1];
              console.log(`‚ö†Ô∏è Keine vollst√§ndige Kerze gefunden, verwende letzte Kerze f√ºr ${cryptoId}:`, lastCandle);
              return lastCandle;
            }
            
            // Berechne prozentualen Ma√üstab f√ºr 1h Kerzen
            function calculatePercentage1hScale() {
              console.log(`üïØÔ∏è Berechne prozentualen Ma√üstab f√ºr 1h Kerzen`);
              
              const all1hData = [];
              
              // Sammle alle verf√ºgbaren 1h Kerzen-Daten
              Object.keys(current1hCandleCache).forEach(cryptoId => {
                const data = current1hCandleCache[cryptoId];
                if (data) {
                  all1hData.push(data);
                }
              });
              
              // Falls keine Daten im Cache, generiere aus Mini-Candlestick-Daten
              if (all1hData.length === 0) {
                Object.keys(candlestickDataCache).forEach(cryptoId => {
                  const generatedData = generateCurrent1hCandleData(cryptoId);
                  if (generatedData) {
                    all1hData.push(generatedData);
                  }
                });
              }
              
              if (all1hData.length === 0) {
                console.log(`‚ö†Ô∏è Keine 1h Kerzen-Daten f√ºr Ma√üstab-Berechnung verf√ºgbar`);
                return null;
              }
              
              // Berechne prozentuale √Ñnderungen f√ºr alle Kerzen
              const percentageChanges = all1hData.map(candle => {
                const open = parseFloat(candle.open);
                const high = parseFloat(candle.high);
                const low = parseFloat(candle.low);
                const close = parseFloat(candle.close);
                
                // Berechne prozentuale √Ñnderungen
                const highChange = ((high - open) / open) * 100;
                const lowChange = ((low - open) / open) * 100;
                const closeChange = ((close - open) / open) * 100;
                
                return {
                  highChange: highChange,
                  lowChange: lowChange,
                  closeChange: closeChange,
                  maxChange: Math.max(highChange, Math.abs(lowChange)),
                  data: candle
                };
              });
              
              // Finde die maximale prozentuale √Ñnderung
              const maxPercentageChange = Math.max(...percentageChanges.map(p => p.maxChange));
              
              console.log(`üìä Prozentualer 1h Ma√üstab: Max. √Ñnderung=${maxPercentageChange.toFixed(2)}%`);
              
              return {
                maxPercentageChange: maxPercentageChange,
                percentageChanges: percentageChanges
              };
            }

// Zeichne Mini-Candlesticks
function drawMiniCandlesticks(canvas, data) {
  console.log(`üïØÔ∏è drawMiniCandlesticks aufgerufen f√ºr Canvas:`, canvas);
  console.log(`üïØÔ∏è Daten:`, data);
  console.log(`üïØÔ∏è Daten-Typ:`, typeof data);
  console.log(`üïØÔ∏è Daten-L√§nge:`, data ? data.length : 'undefined');
  
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  
  console.log(`üïØÔ∏è Canvas-Dimensionen: ${width}x${height}`);
  
  // Clear canvas
  ctx.clearRect(0, 0, width, height);
  
  if (!data || data.length === 0) {
    console.log('‚ö†Ô∏è Keine Candlestick-Daten verf√ºgbar - Mini-Chart bleibt leer');
    
    // Zeichne einen Platzhalter-Text
    ctx.fillStyle = '#6c757d';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Keine Daten', width / 2, height / 2);
    return;
  }
  
  // Debug: Zeige die ersten und letzten Kerzen
  if (data.length > 0) {
    console.log(`üïØÔ∏è Erste Kerze:`, data[0]);
    console.log(`üïØÔ∏è Letzte Kerze:`, data[data.length - 1]);
  }
  
  const candleWidth = width / data.length;
  const padding = 2;
  const availableHeight = height - 4;
  
  // Konvertiere alle Preise zu Numbers und finde min/max f√ºr Skalierung
  const processedData = data.map(d => ({
    open: parseFloat(d.open),
    high: parseFloat(d.high),
    low: parseFloat(d.low),
    close: parseFloat(d.close),
    isGreen: d.isGreen || parseFloat(d.close) > parseFloat(d.open)
  }));
  
  const allPrices = processedData.flatMap(d => [d.low, d.high]);
  const minPrice = Math.min(...allPrices);
  const maxPrice = Math.max(...allPrices);
  const priceRange = maxPrice - minPrice;
  
  processedData.forEach((candle, index) => {
    const x = index * candleWidth + padding;
    const candleX = x + candleWidth * 0.1;
    const candleW = candleWidth * 0.8;
    
    // Skaliere Preise auf Canvas-H√∂he
    const highY = ((maxPrice - candle.high) / priceRange) * availableHeight + 2;
    const lowY = ((maxPrice - candle.low) / priceRange) * availableHeight + 2;
    const openY = ((maxPrice - candle.open) / priceRange) * availableHeight + 2;
    const closeY = ((maxPrice - candle.close) / priceRange) * availableHeight + 2;
    
    // Zeichne Docht (High-Low Linie)
    ctx.strokeStyle = candle.isGreen ? '#28a745' : '#dc3545';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x + candleWidth / 2, highY);
    ctx.lineTo(x + candleWidth / 2, lowY);
    ctx.stroke();
    
    // Zeichne Kerze (Open-Close Rechteck)
    const candleTop = Math.min(openY, closeY);
    const candleBottom = Math.max(openY, closeY);
    const candleHeight = Math.abs(closeY - openY);
    
    if (candleHeight === 0) {
      // Doji - nur horizontale Linie
      ctx.strokeStyle = candle.isGreen ? '#28a745' : '#dc3545';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(candleX, openY);
      ctx.lineTo(candleX + candleW, openY);
      ctx.stroke();
    } else {
      // Normale Kerze
      ctx.fillStyle = candle.isGreen ? '#28a745' : '#dc3545';
      ctx.fillRect(candleX, candleTop, candleW, candleHeight);
      
      // Kerzen-Rand
      ctx.strokeStyle = candle.isGreen ? '#28a745' : '#dc3545';
      ctx.lineWidth = 1;
      ctx.strokeRect(candleX, candleTop, candleW, candleHeight);
    }
  });
}

// Update Candlestick-Info
function updateCandlestickInfo(infoDiv, candle) {
  // Konvertiere Strings zu Numbers f√ºr toFixed()
  const open = parseFloat(candle.open);
  const high = parseFloat(candle.high);
  const low = parseFloat(candle.low);
  const close = parseFloat(candle.close);
  
  infoDiv.querySelector('.open-price').textContent = open.toFixed(2);
  infoDiv.querySelector('.high-price').textContent = high.toFixed(2);
  infoDiv.querySelector('.low-price').textContent = low.toFixed(2);
  infoDiv.querySelector('.close-price').textContent = close.toFixed(2);
}

// Update Mini-Candlestick-Info mit Prozentwerten der letzten vollst√§ndigen Kerze
function updateMiniCandlestickInfo(infoDiv, candle) {
  // Konvertiere Strings zu Numbers f√ºr Berechnungen
  const open = parseFloat(candle.open);
  const high = parseFloat(candle.high);
  const low = parseFloat(candle.low);
  const close = parseFloat(candle.close);
  
  // Berechne prozentuale √Ñnderungen
  const highChange = ((high - open) / open) * 100;
  const lowChange = ((low - open) / open) * 100;
  const closeChange = ((close - open) / open) * 100;
  
  // Update Tooltip mit Prozentwerten
  infoDiv.querySelector('.open-price').textContent = open.toFixed(2);
  infoDiv.querySelector('.high-price').textContent = `${high.toFixed(2)} (${highChange >= 0 ? '+' : ''}${highChange.toFixed(2)}%)`;
  infoDiv.querySelector('.low-price').textContent = `${low.toFixed(2)} (${lowChange >= 0 ? '+' : ''}${lowChange.toFixed(2)}%)`;
  infoDiv.querySelector('.close-price').textContent = `${close.toFixed(2)} (${closeChange >= 0 ? '+' : ''}${closeChange.toFixed(2)}%)`;
  
  console.log(`üïØÔ∏è Mini-Candlestick-Tooltip aktualisiert: Open=${open}, High=${high} (${highChange.toFixed(2)}%), Low=${low} (${lowChange.toFixed(2)}%), Close=${close} (${closeChange.toFixed(2)}%)`);
}

// Update 1h Kerzen-Info mit Prozentwerten
function update1hCandleInfo(infoDiv, candle) {
  // Konvertiere Strings zu Numbers f√ºr Berechnungen
  const open = parseFloat(candle.open);
  const high = parseFloat(candle.high);
  const low = parseFloat(candle.low);
  const close = parseFloat(candle.close);
  
  // Berechne prozentuale √Ñnderungen
  const highChange = ((high - open) / open) * 100;
  const lowChange = ((low - open) / open) * 100;
  const closeChange = ((close - open) / open) * 100;
  
  // Update Tooltip mit Prozentwerten
  infoDiv.querySelector('.open-price').textContent = open.toFixed(2);
  infoDiv.querySelector('.high-price').textContent = `${high.toFixed(2)} (${highChange >= 0 ? '+' : ''}${highChange.toFixed(2)}%)`;
  infoDiv.querySelector('.low-price').textContent = `${low.toFixed(2)} (${lowChange >= 0 ? '+' : ''}${lowChange.toFixed(2)}%)`;
  infoDiv.querySelector('.close-price').textContent = `${close.toFixed(2)} (${closeChange >= 0 ? '+' : ''}${closeChange.toFixed(2)}%)`;
  
  console.log(`üïØÔ∏è 1h Kerzen-Tooltip aktualisiert: Open=${open}, High=${high} (${highChange.toFixed(2)}%), Low=${low} (${lowChange.toFixed(2)}%), Close=${close} (${closeChange.toFixed(2)}%)`);
}

// Zeichne aktuelle 1h Kerze
function drawCurrent1hCandle(canvas, data) {
  console.log(`üïØÔ∏è drawCurrent1hCandle aufgerufen f√ºr Canvas:`, canvas);
  console.log(`üïØÔ∏è 1h Daten:`, data);
  
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  
  console.log(`üïØÔ∏è 1h Canvas-Dimensionen: ${width}x${height}`);
  
  // Clear canvas
  ctx.clearRect(0, 0, width, height);
  
  if (!data) {
    console.log('‚ö†Ô∏è Keine 1h Kerzen-Daten verf√ºgbar - Chart bleibt leer');
    
    // Zeichne einen Platzhalter-Text
    ctx.fillStyle = '#6c757d';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Keine Daten', width / 2, height / 2);
    return;
  }
  
  // Debug: Zeige die 1h Kerze Details
  console.log(`üïØÔ∏è 1h Kerze Details:`, {
    open: data.open,
    high: data.high,
    low: data.low,
    close: data.close,
    isGreen: data.isGreen,
    isComplete: data.isComplete,
    isCurrentHour: data.isCurrentHour,
    timestamp: data.timestamp
  });
  
  // Debug: Zeige die 1h Kerze
  console.log(`üïØÔ∏è 1h Kerze:`, data);
  console.log(`üïØÔ∏è Ist abgeschlossen:`, data.isComplete);
  
  // Zeichne die einzelne 1h Kerze
  const candleWidth = width * 0.6;
  const availableHeight = height * 0.8;
  const candleX = (width - candleWidth) / 2;
  const candleY = (height - availableHeight) / 2;
  
  // Verwende prozentualen Ma√üstab f√ºr alle 1h Kerzen
  const percentageScale = calculatePercentage1hScale();
  
  let openPrice, highPrice, lowPrice, closePrice;
  let maxPercentageChange;
  
  if (percentageScale && percentageScale.maxPercentageChange > 0) {
    // Verwende prozentualen Ma√üstab
    openPrice = parseFloat(data.open);
    highPrice = parseFloat(data.high);
    lowPrice = parseFloat(data.low);
    closePrice = parseFloat(data.close);
    maxPercentageChange = percentageScale.maxPercentageChange;
    
    console.log(`üïØÔ∏è Verwende prozentualen Ma√üstab: Max. √Ñnderung=${maxPercentageChange.toFixed(2)}%`);
  } else {
    // Fallback: Verwende lokalen Ma√üstab
    openPrice = parseFloat(data.open);
    highPrice = parseFloat(data.high);
    lowPrice = parseFloat(data.low);
    closePrice = parseFloat(data.close);
    
    // Berechne lokale prozentuale √Ñnderungen
    const highChange = ((highPrice - openPrice) / openPrice) * 100;
    const lowChange = ((lowPrice - openPrice) / openPrice) * 100;
    maxPercentageChange = Math.max(highChange, Math.abs(lowChange));
    
    console.log(`üïØÔ∏è Verwende lokalen prozentualen Ma√üstab: Max. √Ñnderung=${maxPercentageChange.toFixed(2)}%`);
  }
  
  if (maxPercentageChange === 0) {
    // Doji - nur horizontale Linie
    ctx.strokeStyle = data.isGreen ? '#28a745' : '#dc3545';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(candleX, height / 2);
    ctx.lineTo(candleX + candleWidth, height / 2);
    ctx.stroke();
  } else {
    // Normale Kerze mit prozentualer Skalierung
    const centerY = height / 2; // Mittellinie (Open-Preis)
    
    // Berechne prozentuale √Ñnderungen
    const highChange = ((highPrice - openPrice) / openPrice) * 100;
    const lowChange = ((lowPrice - openPrice) / openPrice) * 100;
    const closeChange = ((closePrice - openPrice) / openPrice) * 100;
    
    // Skaliere prozentuale √Ñnderungen auf Canvas-H√∂he
    const scaleFactor = availableHeight / (maxPercentageChange * 2); // *2 f√ºr positive und negative √Ñnderungen
    
    const highY = centerY - (highChange * scaleFactor);
    const lowY = centerY - (lowChange * scaleFactor);
    const openY = centerY; // Open-Preis ist immer in der Mitte
    const closeY = centerY - (closeChange * scaleFactor);
    
    // Zeichne Docht (High-Low Linie)
    ctx.strokeStyle = data.isGreen ? '#28a745' : '#dc3545';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(candleX + candleWidth / 2, highY);
    ctx.lineTo(candleX + candleWidth / 2, lowY);
    ctx.stroke();
    
    // Zeichne Kerze (Open-Close Rechteck)
    const candleTop = Math.min(openY, closeY);
    const candleBottom = Math.max(openY, closeY);
    const candleBodyHeight = Math.abs(closeY - openY);
    
    if (candleBodyHeight === 0) {
      // Doji - nur horizontale Linie
      ctx.strokeStyle = data.isGreen ? '#28a745' : '#dc3545';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(candleX, openY);
      ctx.lineTo(candleX + candleWidth, openY);
      ctx.stroke();
    } else {
      // Normale Kerze
      ctx.fillStyle = data.isGreen ? '#28a745' : '#dc3545';
      ctx.fillRect(candleX, candleTop, candleWidth, candleBodyHeight);
      
      // Kerzen-Rand
      ctx.strokeStyle = data.isGreen ? '#28a745' : '#dc3545';
      ctx.lineWidth = 1;
      ctx.strokeRect(candleX, candleTop, candleWidth, candleBodyHeight);
    }
  }
  
  // Markiere verschiedene Zust√§nde der Kerze
  canvas.classList.remove('incomplete', 'complete', 'old');
  
  if (data.isCurrentHour) {
    if (!data.isComplete) {
      canvas.classList.add('incomplete'); // Aktuelle Stunde, noch nicht abgeschlossen
    } else {
      canvas.classList.add('complete'); // Aktuelle Stunde, abgeschlossen
    }
  } else {
    canvas.classList.add('old'); // √Ñltere Kerze
  }
}

            // ActionCable f√ºr Live-Updates der Mini-Candlesticks und 1h Kerzen
            if (typeof App !== 'undefined' && App.cable) {
              const channel = App.cable.subscriptions.create("PricesChannel", {
                received(data) {
                  if (data.type === 'price') {
                    const container = document.querySelector(`[data-crypto-id="${data.cryptocurrency_id}"]`);
                    if (container) {
                      // Update Mini-Candlestick
                      const miniCanvas = container.querySelector('.mini-candlestick');
                      if (miniCanvas) {
                        updateMiniCandlestick(miniCanvas, data.price, data.cryptocurrency_id);
                      }
                      
                      // Update 1h Kerze
                      const current1hCanvas = container.querySelector('.current-1h-candle');
                      if (current1hCanvas) {
                        updateCurrent1hCandle(current1hCanvas, data.price, data.cryptocurrency_id);
                      }
                    }
                  }
                }
              });
            }

            // Update Mini-Candlestick mit neuem Preis
            function updateMiniCandlestick(canvas, newPrice, cryptoId) {
              console.log(`üïØÔ∏è Update Mini-Candlestick f√ºr ${cryptoId}: $${newPrice}`);
              
              // Lade aktuelle Candlestick-Daten
              let candlestickData = loadRealCandlestickData(cryptoId);
              
              if (candlestickData.length > 0) {
                // Update die rechte Kerze (letzte) mit dem neuen Preis
                const lastCandle = candlestickData[candlestickData.length - 1];
                
                // Konvertiere zu Numbers f√ºr Vergleich
                const currentHigh = parseFloat(lastCandle.high);
                const currentLow = parseFloat(lastCandle.low);
                const currentOpen = parseFloat(lastCandle.open);
                const newPriceNum = parseFloat(newPrice);
                
                // Wenn der neue Preis h√∂her ist als der aktuelle High, update High
                if (newPriceNum > currentHigh) {
                  lastCandle.high = newPriceNum;
                }
                
                // Wenn der neue Preis niedriger ist als der aktuelle Low, update Low
                if (newPriceNum < currentLow) {
                  lastCandle.low = newPriceNum;
                }
                
                // Update Close-Preis
                lastCandle.close = newPriceNum;
                
                // Update isGreen basierend auf Open vs Close
                lastCandle.isGreen = newPriceNum > currentOpen;
                
                // Zeichne die aktualisierten Candlesticks
                drawMiniCandlesticks(canvas, candlestickData);
                
                console.log(`‚úÖ Mini-Candlestick aktualisiert f√ºr ${cryptoId}`);
              }
            }
            
            // Update aktuelle 1h Kerze mit neuem Preis
            function updateCurrent1hCandle(canvas, newPrice, cryptoId) {
              console.log(`üïØÔ∏è Update 1h Kerze f√ºr ${cryptoId}: $${newPrice}`);
              
              // Lade aktuelle 1h Kerzen-Daten
              let current1hData = loadCurrent1hCandleData(cryptoId);
              
              if (current1hData) {
                // Konvertiere zu Numbers f√ºr Vergleich
                const currentHigh = parseFloat(current1hData.high);
                const currentLow = parseFloat(current1hData.low);
                const currentOpen = parseFloat(current1hData.open);
                const newPriceNum = parseFloat(newPrice);
                
                // Wenn der neue Preis h√∂her ist als der aktuelle High, update High
                if (newPriceNum > currentHigh) {
                  current1hData.high = newPriceNum;
                }
                
                // Wenn der neue Preis niedriger ist als der aktuelle Low, update Low
                if (newPriceNum < currentLow) {
                  current1hData.low = newPriceNum;
                }
                
                // Update Close-Preis
                current1hData.close = newPriceNum;
                
                // Update isGreen basierend auf Open vs Close
                current1hData.isGreen = newPriceNum > currentOpen;
                
                // Zeichne die aktualisierte 1h Kerze
                drawCurrent1hCandle(canvas, current1hData);
                
                console.log(`‚úÖ 1h Kerze aktualisiert f√ºr ${cryptoId}`);
                
                // Zeichne alle 1h Kerzen neu, um gleichen Ma√üstab zu gew√§hrleisten
                setTimeout(() => {
                  redrawAll1hCandles();
                }, 100);
              }
            }

            // Update Mini-Candlestick mit neuen Candle-Daten vom Server
            function updateMiniCandlestickWithCandles(canvas, newCandles, cryptoId) {
              console.log(`üïØÔ∏è Update Mini-Candlestick mit Candle-Daten f√ºr ${cryptoId}:`, newCandles);
              
              if (newCandles && newCandles.length > 0) {
                // Zeichne die neuen Candlesticks direkt
                drawMiniCandlesticks(canvas, newCandles);
                
                console.log(`‚úÖ Mini-Candlestick mit Candle-Daten aktualisiert f√ºr ${cryptoId}`);
              }
            }

            // Behandle Candle-Updates von ActionCable
            function handleCandleUpdate(data) {
              console.log(`üïØÔ∏è Candle-Update erhalten f√ºr ${data.symbol}:`, data.candles);
              console.log(`üîç Suche nach Container mit data-crypto-id="${data.cryptocurrency_id}"`);
              
              // Debug: Zeige alle verf√ºgbaren data-crypto-id Attribute
              const allContainers = document.querySelectorAll('[data-crypto-id]');
              console.log(`üîç Verf√ºgbare data-crypto-id Attribute:`, Array.from(allContainers).map(c => c.getAttribute('data-crypto-id')));
              
              // Update die gecachten Daten
              updateCandlestickDataCache(data.cryptocurrency_id, data.candles);
              
              const container = document.querySelector(`[data-crypto-id="${data.cryptocurrency_id}"]`);
              if (container) {
                console.log(`‚úÖ Container gefunden f√ºr ${data.symbol}`);
                const canvas = container.querySelector('.mini-candlestick');
                if (canvas) {
                  console.log(`‚úÖ Canvas gefunden f√ºr ${data.symbol}`);
                  // Update Mini-Candlestick mit neuen Candle-Daten
                  updateMiniCandlestickWithCandles(canvas, data.candles, data.cryptocurrency_id);
                } else {
                  console.log(`[!] Mini-Candlestick Canvas nicht gefunden f√ºr ${data.symbol}`);
                }
              } else {
                console.log(`[!] Container nicht gefunden f√ºr Crypto ID: ${data.cryptocurrency_id} (${data.symbol})`);
              }
            }
            
            // Funktion zum Aktualisieren der Mini-Candlesticks mit neuem Timeframe
            function refreshMiniCandlesticks(timeframe) {
              console.log(`üïØÔ∏è Aktualisiere Mini-Candlesticks f√ºr Timeframe: ${timeframe}`);
              
              // Lade neue Candle-Daten vom Server f√ºr alle Cryptos
              fetch(`/cryptocurrencies/mini_candlestick_data?timeframe=${timeframe}`)
                .then(response => response.json())
                .then(data => {
                  console.log(`üìä Neue Candle-Daten erhalten f√ºr ${Object.keys(data).length} Cryptos`);
                  
                  // Update die gecachten Daten
                  Object.keys(data).forEach(cryptoId => {
                    updateCandlestickDataCache(cryptoId, data[cryptoId] || []);
                  });
                  
                  // Update alle Mini-Candlesticks
                  const candlestickCanvases = document.querySelectorAll('.mini-candlestick');
                  candlestickCanvases.forEach(canvas => {
                    const cryptoId = canvas.dataset.cryptoId;
                    const candlestickData = data[cryptoId] || [];
                    
                    if (candlestickData.length > 0) {
                      drawMiniCandlesticks(canvas, candlestickData);
                      console.log(`‚úÖ Mini-Candlestick aktualisiert f√ºr ${cryptoId} mit ${candlestickData.length} Kerzen`);
                    } else {
                      console.log(`‚ö†Ô∏è Keine aktuellen Daten f√ºr ${cryptoId} - zeichne leeren Chart`);
                      drawMiniCandlesticks(canvas, []);
                    }
                  });
                })
                .catch(error => {
                  console.error('‚ùå Fehler beim Laden der Mini-Candlestick-Daten:', error);
                });
            }
            
            // Starte automatischen Refresh f√ºr 1h Kerzen (alle 5 Minuten)
            setInterval(() => {
              refreshCurrent1hCandles();
            }, 5 * 60 * 1000); // 5 Minuten
            
            // Manuelle Initialisierung der 1h Kerzen nach 2 Sekunden
            setTimeout(() => {
              console.log('üïØÔ∏è Manuelle Initialisierung der 1h Kerzen...');
              refreshCurrent1hCandles();
            }, 2000);
            
            // Funktion zum Neuziehen aller 1h Kerzen mit gleichem prozentualen Ma√üstab
            function redrawAll1hCandles() {
              console.log(`üïØÔ∏è Zeichne alle 1h Kerzen mit gleichem prozentualen Ma√üstab neu`);
              
              const current1hCanvases = document.querySelectorAll('.current-1h-candle');
              current1hCanvases.forEach(canvas => {
                const cryptoId = canvas.dataset.cryptoId;
                const data = current1hCandleCache[cryptoId] || generateCurrent1hCandleData(cryptoId);
                
                if (data) {
                  drawCurrent1hCandle(canvas, data);
                  console.log(`‚úÖ 1h Kerze neu gezeichnet f√ºr ${cryptoId}`);
                }
              });
            }
            
            // Funktion zum Aktualisieren der 1h Kerzen
            function refreshCurrent1hCandles() {
              console.log(`üïØÔ∏è Aktualisiere 1h Kerzen`);
              
              // Berechne zuerst den prozentualen Ma√üstab
              const percentageScale = calculatePercentage1hScale();
              console.log(`üïØÔ∏è Prozentualer Ma√üstab f√ºr Update:`, percentageScale);
              
              // Update alle 1h Kerzen mit generierten Daten
              const current1hCanvases = document.querySelectorAll('.current-1h-candle');
              current1hCanvases.forEach(canvas => {
                const cryptoId = canvas.dataset.cryptoId;
                const generatedData = generateCurrent1hCandleData(cryptoId);
                
                if (generatedData) {
                  updateCurrent1hCandleCache(cryptoId, generatedData);
                  drawCurrent1hCandle(canvas, generatedData);
                  console.log(`‚úÖ 1h Kerze aktualisiert f√ºr ${cryptoId}`);
                } else {
                  console.log(`‚ö†Ô∏è Keine 1h Daten f√ºr ${cryptoId} - zeichne leeren Chart`);
                  drawCurrent1hCandle(canvas, null);
                }
              });
            }


</script> 